<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>利用Docker构建开发环境 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="最近接触PAAS相关的知识，在研发过程中开始使用Docker搭建了自己完整的开发环境，感觉生活在PAAS时代的程序员真是幸福，本文会简要介绍下Docker是什么，如何利用Docker来搭建自己的开发环境（本文主要是面向Mac OS X），以及期间所遇到的一些坑和解决方案。（本文会要求你对PAAS、LXC、CGroup、AUFS有一定的了解基础，请自行Google ） 大背景–虚拟化技术历史 计算">
<meta property="og:type" content="article">
<meta property="og:title" content="利用Docker构建开发环境">
<meta property="og:url" content="http://yoursite.com/2016/03/05/docker-develop/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="最近接触PAAS相关的知识，在研发过程中开始使用Docker搭建了自己完整的开发环境，感觉生活在PAAS时代的程序员真是幸福，本文会简要介绍下Docker是什么，如何利用Docker来搭建自己的开发环境（本文主要是面向Mac OS X），以及期间所遇到的一些坑和解决方案。（本文会要求你对PAAS、LXC、CGroup、AUFS有一定的了解基础，请自行Google ） 大背景–虚拟化技术历史 计算">
<meta property="og:updated_time" content="2016-03-04T16:46:06.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="利用Docker构建开发环境">
<meta name="twitter:description" content="最近接触PAAS相关的知识，在研发过程中开始使用Docker搭建了自己完整的开发环境，感觉生活在PAAS时代的程序员真是幸福，本文会简要介绍下Docker是什么，如何利用Docker来搭建自己的开发环境（本文主要是面向Mac OS X），以及期间所遇到的一些坑和解决方案。（本文会要求你对PAAS、LXC、CGroup、AUFS有一定的了解基础，请自行Google ） 大背景–虚拟化技术历史 计算">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-docker-develop" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/05/docker-develop/" class="article-date">
  <time datetime="2016-03-04T16:45:31.000Z" itemprop="datePublished">2016-03-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Docker/">Docker</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      利用Docker构建开发环境
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近接触PAAS相关的知识，在研发过程中开始使用Docker搭建了自己完整的开发环境，感觉生活在PAAS时代的程序员真是幸福，本文会简要介绍下Docker是什么，如何利用Docker来搭建自己的开发环境（本文主要是面向Mac OS X），以及期间所遇到的一些坑和解决方案。（本文会要求你对PAAS、LXC、CGroup、AUFS有一定的了解基础，请自行Google ）</p>
<p>大背景–虚拟化技术历史</p>
<p>计算机虚拟化技术由来已久，从硬件仿真到全虚拟化，再到准虚拟化和操作系统虚拟化，各种技术粉墨登场，种类繁多，说实在的有点眼花缭乱和复杂；但用户的核心诉求一直是比较简单的，降低信息技术（IT）的运营成本，提高资源利用率，提高安全性和可靠性等等；虽说用户的核心诉求比较简单，但每个时代的需求场景却是不同的。在大型机时代，虚拟化技术被用来支持多个用户能够同时使用大型机，在x86架构时代，随着企业服务的大规模部署，虚拟化技术主要是用来提高企业资源的利用率，而现如今，随着云计算时代的到来，人们对应用的安全性、隔离性越来越高，对于部署的标准化以及虚拟机的性能要求越来越高。现如今，一种叫Linux容器的虚拟化技术逐渐得到广泛的应用，它的优点有许多，本文不一一赘述，有太多的文章可以参考。</p>
<p>什么是Docker？</p>
<p>docker的英文本意是码头工人，也就是搬运工，这种搬运工搬运的是集装箱（Container），集装箱里面装的可不是商品货物，而是任意类型的App，Docker把App（叫Payload）装在Container内，通过Linux Container技术的包装将App变成一种标准化的、可移植的、自管理的组件，这种组件可以在你的latop上开发、调试、运行，最终非常方便和一致地运行在production环境下。</p>
<p>Docker的核心底层技术是LXC（Linux Container），Docker在其上面加了薄薄的一层，添加了许多有用的功能。这篇stackoverflow上的问题和答案很好地诠释了Docker和LXC的区别，能够让你更好的了解什么是Docker， 简单翻译下就是以下几点：</p>
<p>Docker提供了一种可移植的配置标准化机制，允许你一致性地在不同的机器上运行同一个Container；而LXC本身可能因为不同机器的不同配置而无法方便地移植运行；<br>Docker以App为中心，为应用的部署做了很多优化，而LXC的帮助脚本主要是聚焦于如何机器启动地更快和耗更少的内存；<br>Docker为App提供了一种自动化构建机制（Dockerfile），包括打包，基础设施依赖管理和安装等等；<br>Docker提供了一种类似git的Container版本化的机制，允许你对你创建过的容器进行版本管理，依靠这种机制，你还可以下载别人创建的Container，甚至像git那样进行合并；<br>Docker Container是可重用的，依赖于版本化机制，你很容易重用别人的Container（叫Image），作为基础版本进行扩展；<br>Docker Container是可共享的，有点类似github一样，Docker有自己的INDEX，你可以创建自己的Docker用户并上传和下载Docker Image；<br>Docker提供了很多的工具链，形成了一个生态系统；这些工具的目标是自动化、个性化和集成化，包括对PAAS平台的支持等；<br>那么Docker有什么用呢？对于运维来说，Docker提供了一种可移植的标准化部署过程，使得规模化、自动化、异构化的部署成为可能甚至是轻松简单的事情；而对于开发者来说，Docker提供了一种开发环境的管理方法，包括映像、构建、共享等功能，而后者是本文的主题。</p>
<p>Docker的安装和构成</p>
<p>Docker官方本身提供了非常具体的安装教程，这里不说具体的安装过程，请参考Docker安装（Mac系统），重要的是描述下原理和安装完成后的结构，好对Docker更好的了解。 由于LXC本身不支持Mac内核，因此需要跑一个VirtualBox虚拟机（TinyCoreLinux）来安装，幸好Docker社区提供了一个非常方便的工具boot2docker（其实就是一个VBoxManage的包装shell脚本），用于安装Mac下的整个Docker环境。具体的结构如下：</p>
<p>docker-install</p>
<p>如图所示，安装完成后，具体情况如下：</p>
<p>在Mac的home目录~/.boot2docker下创建了虚拟机所需要的文件，其中boot2docker.iso是虚拟机映像，这是一个由CD-ROM引导的TinyCoreLinux系统；而boot2docker-vm.vmdk文件则是你的虚拟机磁盘，你所有的持久化数据都存放在这里，包括docker创建的lxc容器等文件。<br>在Mac下，docker被分为客户端docker-client和服务端docker-daemon两部分，如果是在linux（比如ubuntu），实际上则是同一个可执行文件同时充当客户端和服务端。docker-daemon可以监听unix scoket，也可以在tcp socket（默认端口为4234），docker-client会通过一个叫DOCKER_HOST的环境变量读取服务地址和端口，因此你应该在你的bash_profile文件里面添加这么一行：</p>
<p>export DOCKER_HOST=tcp://127.0.0.1:4243</p>
<p>1<br>2<br>export DOCKER_HOST=tcp://127.0.0.1:4243</p>
<p>docker-daemon跑在虚拟机上，这个程序实际上就是接收docker-client发送过来的消息命令，创建、启动和销毁lxc容器，以及docker本身的版本管理、映像存储等等 运行你的第一个docker容器 安装完成后，就差不多可以开始创建和运行docker容器了，在这之前，你首先得下载一个Image，什么是Image？我们先来了解docker的2个基础概念：Image和Container。</p>
<p>Container和Image 在Docker的世界里，Image是指一个只读的层（Layer），这里的层是AUFS里的概念，最直观的方式就是看一下docker官方给出的图：</p>
<p>docker-filesystems-multilayer</p>
<p>Docker使用了一种叫AUFS的文件系统，这种文件系统可以让你一层一层地叠加修改你的文件，最底下的文件系统是只读的，如果需要修改文件，AUFS会增加一个可写的层（Layer），这样有很多好处，例如不同的Container可以共享底层的只读文件系统（同一个Kernel），使得你可以跑N多个Container而不至于你的硬盘被挤爆了！这个只读的层就是Image！而如你所看到的，一个可写的层就是Container。</p>
<p>那Image和Container的区别是什么？很简单，他们的区别仅仅是一个是只读的层，一个是可写的层，你可以使用docker commit 命令，将你的Container变成一个Image，也就是提交你所运行的Container的修改内容，变成一个新的只读的Image，这非常类似于git commit命令，感觉真棒！</p>
<p>实际上这就是Docker对Container映像的版本管理基石，AUFS文件系统实在是太美妙了，更多细节可以参考DotCloud的这篇文章。</p>
<p>运行和退出</p>
<p>在了解了Image和Container的概念后，我们可以开始下载一个Image，Docker的好处就是提供了一个类似github的Image仓库管理，你可以非常方便pull别人的Image下来运行，例如，我们可以下载一个ubuntu Image：</p>
<p>docker pull ubuntu:13.10 </p>
<p>1<br>2<br>docker pull ubuntu:13.10 </p>
<p>这里的13.10是一个Tag，类似于git的tag，这里的tag可以为你制定一个ubuntu的版本。下载完成后，执行docker images命令可以列出你已经下载或者自己构建的image：（请允许我使用可爱的马赛克 :) ）</p>
<p>QQ20140322-1</p>
<p>你可以看到ubuntu:13.10的大小为178MB，以及它的IMAGE ID。 现在我们开始运行一个Container，命令很简单，例如我们想运行一个执行Shell终端的Container：</p>
<p>QQ20140322-2</p>
<p>如你看到的，你已经进入到一个Shell里面，可以执行你想执行的任何命令，就和在ubuntu里面一样，进去后默认是在根目录/下，可以看到经典的unix/linux目录结构，以及你所运行的bash版本等信息。你可以给你的Container定一个名字，通过–name选项，例如这里命名了shell，日后你就可以直接用这个名字引用Contanier。</p>
<p>退出一个Container也很简单，你直接exit就好了。 其他更多的命令这里不做赘述，因为官方的文档已经非常全面，这里只是给一个直观的初步印象。下面进入主题。</p>
<p>利用Docker搭建开发环境</p>
<p>我们先看看程序员在搭建开发环境时遇到的一些问题：</p>
<p>软件安装麻烦，比如很多公司都使用redhat，一般开发人员又不给root，安装一个nginx或者是mysql都得自己下载编译安装 权限问题，没有root，一些软件无法运行，例如dnsmasq；<br>没有root，无法修改hosts，无法netstat -nptl，无法tcpdump，无法iptable<br>隔离性差，例如不同的开发人员如果在同一台主机环境下共享开发，虽然是用户隔离，但端口如果不规范可能会冲突；同一个Mysql如果权限管理不好很有可能误删别人的数据<br>可移植性差，例如和生产环境不一致，开发人员之间也无法共享；更严重的情况是当有新人入职时，通常需要又折腾一遍开发环境，无法快速搭建<br>这些问题可以通过在本地搭建虚拟机来解决，但虚拟机是一个很笨重的解决方案，Docker是一个非常轻量级的方案，而且还拥有虚拟机没有的一些功能，例如标准化Image，Image共享等，更重要的是，利用Docker，你可以运行非常多的容器，在你的Mac下搭建一个分布式的开发环境根本不是什么大的问题，而且对内存、磁盘和cpu的消耗相比传统的虚拟机要低许多，这些都要归功于AUFS和LXC这两大神奇的技术。</p>
<p>构建基础Image</p>
<p>想要搭建一个节省磁盘空间和扩展性良好的开发环境，最重要的第一步就是构建一个基础性的Image，比如你的主要开发语言是Ruby，那么你肯定需要一个已经安装好以下工具的基础Image：</p>
<p>ruby<br>bundler<br>gem<br>然后在此基础上，你可以扩展这个基础的Image（下面叫base）为不同的开发环境，例如rails，或者是nats。当然，你的这个base也可以从别人的Image扩展而来，还记得我们刚刚pull下来的ubuntu:13.10这个Image吗？你可以从这个Image扩展开始构建你的base，如何做呢？Docker提供了一种标准化的DSL方式，你只需要编写一个Dockerfile，运行docker build指令，就可以构建你自己的Image，这有点像Makefile和make命令一样，只是大家要构建的内容和构建语言不同。</p>
<p>Dockerfile的语法请参考Dockerfile Reference，这里给出上面提到的Ruby开发的base Dockerfile示例：</p>
<p>FROM ubuntu:13.10<br>RUN apt-get update<br>RUN apt-get install -y ruby ruby-dev gem<br>RUN gem install bundler </p>
<p>1<br>2<br>3<br>4<br>5<br>FROM ubuntu:13.10<br>RUN apt-get update<br>RUN apt-get install -y ruby ruby-dev gem<br>RUN gem install bundler </p>
<p>这里只用到了很简单的2个指令：FROM和RUN，FROM指定了我们要扩展的Image，RUN指定我们要运行的命令，这里是安装ruby，gem、bundler等软件。写好Dockerfile后，运行以下指令就可以创建你的base image了：</p>
<p>docker build –rm -t dev:base . </p>
<p>1<br>2<br>docker build –rm -t dev:base . </p>
<p>-t 选项是你要构建的base image的tag，就好比ubuntu:13.10一样 –rm 选项是告诉Docker在构建完成后删除临时的Container，Dockerfile的每一行指令都会创建一个临时的Container，一般你是不需要这些临时生成的Container的 如你所想，我们可以像运行ubuntu:13.10那样运行我们的base了：</p>
<p>docker run -i -t –name ruby dev:base irb </p>
<p>1<br>2<br>docker run -i -t –name ruby dev:base irb </p>
<p>这里我们使用dev:base这个Image运行了一个irb解释器（Ruby的交互式解释器）。 在构建完base之后，你可以依样画葫芦构建你的rails环境，很简单，只需要FROM dev:base，然后RUN安装你的rails组件就可以了，不再赘述。最终你可能构建的开发环境是这样的：</p>
<p>docker-dev</p>
<p>如上图所示，base和service都是从ubutnu:13.10继承而来，他们作为不同的基础开发环境，base是ruby开发环境（也许命名为dev:ruby更为合适？），而service是一些基础数据服务，例如mysql，memcache，我建议将这些第三方组件集中在一个Container中，因为他们的环境不经常修改，可以作为一种底层服务Container运行，除非你需要构建分布式的服务，例如memcache集群，那可以继续拆分。</p>
<p>指定Image入口</p>
<p>当你构建完你的base Image和其他应用的Image之后，你就可以启动这些Image了，还记得前面我们给出的运行命令吗？</p>
<p>docker run -i -t –name shell dev:base /bin/bash </p>
<p>1<br>2<br>docker run -i -t –name shell dev:base /bin/bash </p>
<p>这里我们运行了一个bash，这样你就可以在shell里面执行你所想要执行的任何命令了，但是我们有时候并不想每次都启动一个shell，接着再在shell里面启动我们的程序，比如一个mysql，而是想一启动一个容器，mysql服务就自动运行了，这很简单，Dockerfile提供了CMD和ENTRYPOINT这2个指令，允许你指定一个Image启动时的默认命令。CMD和ENTRYPOINT的区别是CMD的参数可以由docker run指令指定的参数覆盖，而ENTRYPOINT则不可以。例如我们想运行一个memcached服务，可以这么写Dockerfile：</p>
<p>FROM ubuntu:13.10<br>RUN apt-get install -y memcached CMD memcached -u root -p 40000 </p>
<p>1<br>2<br>3<br>FROM ubuntu:13.10<br>RUN apt-get install -y memcached CMD memcached -u root -p 40000 </p>
<p>或者可以这么写：</p>
<p>FROM ubuntu:13.10<br>RUN apt-get install -y memcached ENTRYPOINT [“memcached”, “-u”, “root”, “-p”, “40000”] </p>
<p>1<br>2<br>3<br>FROM ubuntu:13.10<br>RUN apt-get install -y memcached ENTRYPOINT [“memcached”, “-u”, “root”, “-p”, “40000”] </p>
<p>注意不要把memcached启动为后台进程，即加上-d选项，否则docker启动的container会马上stop掉，这点我也觉得比较意外。 接着我们build这个Image：</p>
<p>docker build -t dev:memcache . </p>
<p>1<br>2<br>docker build -t dev:memcache . </p>
<p>这样，当你build完你的Image后，你可以直接将该Image运行为一个容器，它会自动启动mysql服务：</p>
<p>docker run –name memcache_service -d dev:memcache </p>
<p>1<br>2<br>docker run –name memcache_service -d dev:memcache </p>
<p>注意使用-d (detach) 选项，这样这个container就会作为后台进程运行了，接着你可以使用docker ps命令查看是否有在运行。</p>
<p>磁盘映射</p>
<p>大部分时候你会需要把你host主机（宿主）上的目录映射到Container里面，这样你就非常方便地在host主机上编辑代码，然后直接就可以在Container里面运行它们，而不用手动copy到Container里面再重启Container。按理将host的目录映射到guest（指Container）上应该是一件很容易的事情，就好像VMWare那样，但可惜的是，由于Mac上的Docker多了一层虚拟机，因此多了一层周折，你必须先VM上的目录通过sshfs mount到host（指Mac）上，然后再将你的目录或文件copy到这个mount的目录，再将VM上的这个目录映射到Container里，听起来比较拗口，画个图会清晰很多。</p>
<p>docker-disk-map</p>
<p>如上图所示，VM里面的/mnt/sda1/dev/目录（你需要自己创建）通过sshfs命令mount到了host主机（Mac）的~/workspace/dev/目录 ，而VM里的/mnt/sda1/dev/目录又被映射到了Container的/src/目录下，这样你就可以在Container里面的/src/目录下访问你的host文件了。具体如何做呢？首先你需要安装sshfs命令，然后将VM的password写到一个文件中，例如~/.boot2docker/b2d-passwd，在用sshfs命令mount起VM的/mnt/sda1/dev目录：</p>
<p>brew install sshfs<br>cat tcuser &gt; ~/.boot2docker/b2d-passwd<br>sshfs docker@localhost:/mnt/sda1/dev ~/workspace/dev -p 2022 -o reconnect -o password_stdin &lt; ~/.boot2docker/b2d-passwd </p>
<p>1<br>2<br>3<br>4<br>brew install sshfs<br>cat tcuser &gt; ~/.boot2docker/b2d-passwd<br>sshfs docker@localhost:/mnt/sda1/dev ~/workspace/dev -p 2022 -o reconnect -o password_stdin &lt; ~/.boot2docker/b2d-passwd </p>
<p>接着你在run一个Container的时候需要通过-v选项来将/mnt/sda1/dev/映射到/src目录：</p>
<p>docker run -i -t dev:base -v /mnt/sda1/dev:/src /bin/bash </p>
<p>1<br>2<br>docker run -i -t dev:base -v /mnt/sda1/dev:/src /bin/bash </p>
<p>这样你就可以在你的Container的/src目录下看到你host里的文件了。 磁盘映射还有2个地方需要注意：</p>
<p>你的文件实际上是存储在VM里面的，也就是说你需要将你的目录或者文件copy到VM里面，你sshfs之后，就是copy到~/workspace/dev目录下<br>千万不要sshfs mount非/mnt/sda1下的目录，因为VM里面跑的是TinyCoreLinux，这个OS的rootfs是临时性的（放在内存的，实际上就是boot2docker.iso文件里面的一个rootfs），因此其根目录/下的东西（包括/home）根本不会持久化，只有/mnt/sda1这个目录下的才能持久化。如果你放在/home目录下，只要VM一重启，就会丢失的，/mnt/sda1则不会，实际上就是那个~/.boot2docker-vm.vmdk文件挂载到了/mnt/sda1目录下<br>端口映射</p>
<p>和磁盘映射一样，你有时候会需要将Container的端口映射到host主机上，同样蛋疼的是，由于多了一层VM，端口映射也显得比较麻烦。首先你需要设置VirtualBox的端口映射，然后再将Container的端口映射到你的VM里面：</p>
<p>docker-port-map</p>
<p>具体是这么做的，通过2条命令：</p>
<p>boot2docker ssh -L 8000:localhost:8000<br>docker run -i -t -p 8000:8000</p>
<p>1<br>2<br>3<br>boot2docker ssh -L 8000:localhost:8000<br>docker run -i -t -p 8000:8000</p>
<p>也就是说在docker run的时候通过-p选项指定要映射的端口到VM，而boot2docker ssh命令则是将VM的8000端口映射到了host(Mac)的8000端口，这样你就可以通过Mac的localhost:8000访问Container的8000端口了。 其实，有另一种解决方案就是你不用映射到host（Mac），而是直接登录到VM里面进行访问就好了，boot2docker ssh就可以登录到VM，这样就类似于你的host是ubuntu，但这种解决方案的问题是这个ubuntu太弱了（TinyCoreLinux），如果你在这个ubuntu里面开发代码，或者是运行浏览器，是非常蛋疼的事情，关键还是这个ubuntu是每次重启都会复原的！所以我建议还是做多一层映射好了。 最后，实际上在VM里面，你是可以直接访问所有的Container的端口的，因为VM到Container的网络都是桥接的。</p>
<p>其他的一些坑</p>
<p>在使用的过程中，还遇到一些不少的坑：</p>
<p>/etc/hosts文件无法修改，这样你就不能自己做域名解析<br>VM的系统时间是UTC +0000的，而且貌似无法修改<br>Container的IP无法指定为静态IP，因此每次重启Container时，IP可能会变化<br>第1个问题的解决方案是通过安装dnsmasq软件来做域名解析：</p>
<h1 id="首先，在你的Container里面安装dnsmasq软件"><a href="#首先，在你的Container里面安装dnsmasq软件" class="headerlink" title="首先，在你的Container里面安装dnsmasq软件:"></a>首先，在你的Container里面安装dnsmasq软件:</h1><p>apt-get install dnsmasq</p>
<h1 id="将以下文本添加到-etc-dnsmasq-conf文件的最后："><a href="#将以下文本添加到-etc-dnsmasq-conf文件的最后：" class="headerlink" title="将以下文本添加到 /etc/dnsmasq.conf文件的最后："></a>将以下文本添加到 /etc/dnsmasq.conf文件的最后：</h1><p>listen-address=127.0.0.1 resolv-file=/etc/resolv.dnsmasq.conf conf-dir=/etc/dnsmasq.d user=root</p>
<h1 id="接着在-etc-dnsmasq-d-目录下新建一个文件，随意起个名字"><a href="#接着在-etc-dnsmasq-d-目录下新建一个文件，随意起个名字" class="headerlink" title="接着在/etc/dnsmasq.d/目录下新建一个文件，随意起个名字"></a>接着在/etc/dnsmasq.d/目录下新建一个文件，随意起个名字</h1><p>vi /etc/dnsmqsq.d/dns.conf</p>
<h1 id="指定你要映射的域名，例如google-com，则将下面贴进dns-conf文件"><a href="#指定你要映射的域名，例如google-com，则将下面贴进dns-conf文件" class="headerlink" title="指定你要映射的域名，例如google.com，则将下面贴进dns.conf文件"></a>指定你要映射的域名，例如google.com，则将下面贴进dns.conf文件</h1><p>address=”/google.com/172.17.0.4”</p>
<h1 id="最后退出容器，重启启动容器时，通过-dns选项指定域名服务器"><a href="#最后退出容器，重启启动容器时，通过-dns选项指定域名服务器" class="headerlink" title="最后退出容器，重启启动容器时，通过-dns选项指定域名服务器"></a>最后退出容器，重启启动容器时，通过-dns选项指定域名服务器</h1><p>docker run -i -t -dns 127.0.0.1 -dns 8.8.8.8 dev:base /bin/bash</p>
<h1 id="一定要注意上面添加google的域名服务器8-8-8-8，否则你访问不了外网"><a href="#一定要注意上面添加google的域名服务器8-8-8-8，否则你访问不了外网" class="headerlink" title="一定要注意上面添加google的域名服务器8.8.8.8，否则你访问不了外网"></a>一定要注意上面添加google的域名服务器8.8.8.8，否则你访问不了外网</h1><h1 id="进去Container后，启动dnsmasq，这样你就能够ping-google-com了"><a href="#进去Container后，启动dnsmasq，这样你就能够ping-google-com了" class="headerlink" title="进去Container后，启动dnsmasq，这样你就能够ping google.com了"></a>进去Container后，启动dnsmasq，这样你就能够ping google.com了</h1><p>/etc/init.d/dnsmasq start</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26</p>
<h1 id="首先，在你的Container里面安装dnsmasq软件-1"><a href="#首先，在你的Container里面安装dnsmasq软件-1" class="headerlink" title="首先，在你的Container里面安装dnsmasq软件:"></a>首先，在你的Container里面安装dnsmasq软件:</h1><p>apt-get install dnsmasq</p>
<h1 id="将以下文本添加到-etc-dnsmasq-conf文件的最后：-1"><a href="#将以下文本添加到-etc-dnsmasq-conf文件的最后：-1" class="headerlink" title="将以下文本添加到 /etc/dnsmasq.conf文件的最后："></a>将以下文本添加到 /etc/dnsmasq.conf文件的最后：</h1><p>listen-address=127.0.0.1 resolv-file=/etc/resolv.dnsmasq.conf conf-dir=/etc/dnsmasq.d user=root</p>
<h1 id="接着在-etc-dnsmasq-d-目录下新建一个文件，随意起个名字-1"><a href="#接着在-etc-dnsmasq-d-目录下新建一个文件，随意起个名字-1" class="headerlink" title="接着在/etc/dnsmasq.d/目录下新建一个文件，随意起个名字"></a>接着在/etc/dnsmasq.d/目录下新建一个文件，随意起个名字</h1><p>vi /etc/dnsmqsq.d/dns.conf</p>
<h1 id="指定你要映射的域名，例如google-com，则将下面贴进dns-conf文件-1"><a href="#指定你要映射的域名，例如google-com，则将下面贴进dns-conf文件-1" class="headerlink" title="指定你要映射的域名，例如google.com，则将下面贴进dns.conf文件"></a>指定你要映射的域名，例如google.com，则将下面贴进dns.conf文件</h1><p>address=”/google.com/172.17.0.4”</p>
<h1 id="最后退出容器，重启启动容器时，通过-dns选项指定域名服务器-1"><a href="#最后退出容器，重启启动容器时，通过-dns选项指定域名服务器-1" class="headerlink" title="最后退出容器，重启启动容器时，通过-dns选项指定域名服务器"></a>最后退出容器，重启启动容器时，通过-dns选项指定域名服务器</h1><p>docker run -i -t -dns 127.0.0.1 -dns 8.8.8.8 dev:base /bin/bash</p>
<h1 id="一定要注意上面添加google的域名服务器8-8-8-8，否则你访问不了外网-1"><a href="#一定要注意上面添加google的域名服务器8-8-8-8，否则你访问不了外网-1" class="headerlink" title="一定要注意上面添加google的域名服务器8.8.8.8，否则你访问不了外网"></a>一定要注意上面添加google的域名服务器8.8.8.8，否则你访问不了外网</h1><h1 id="进去Container后，启动dnsmasq，这样你就能够ping-google-com了-1"><a href="#进去Container后，启动dnsmasq，这样你就能够ping-google-com了-1" class="headerlink" title="进去Container后，启动dnsmasq，这样你就能够ping google.com了"></a>进去Container后，启动dnsmasq，这样你就能够ping google.com了</h1><p>/etc/init.d/dnsmasq start</p>
<p>第2个问题的解决方案就稍微麻烦些，起码我没有找到更好的解决方案，我是将boot2docker.iso文件重新制作一次来解决这个问题的：</p>
<h1 id="首先你需要将boot2docker-iso文件mount到一个目录下"><a href="#首先你需要将boot2docker-iso文件mount到一个目录下" class="headerlink" title="首先你需要将boot2docker.iso文件mount到一个目录下"></a>首先你需要将boot2docker.iso文件mount到一个目录下</h1><p>hdiutil mount ~/.boot2docker/boot2docker.iso</p>
<h1 id="系统会mount到-Volumes-boot2docker目录下，然后你最好将这下面的东西copy出来到一个另外的目录，这样我们好制作一张新的ISO"><a href="#系统会mount到-Volumes-boot2docker目录下，然后你最好将这下面的东西copy出来到一个另外的目录，这样我们好制作一张新的ISO" class="headerlink" title="系统会mount到/Volumes/boot2docker目录下，然后你最好将这下面的东西copy出来到一个另外的目录，这样我们好制作一张新的ISO"></a>系统会mount到/Volumes/boot2docker目录下，然后你最好将这下面的东西copy出来到一个另外的目录，这样我们好制作一张新的ISO</h1><p>cp -r /Volumes/boot2docker/* ~/tmp/</p>
<h1 id="接着我们修改以下文件"><a href="#接着我们修改以下文件" class="headerlink" title="接着我们修改以下文件"></a>接着我们修改以下文件</h1><p>vi ~/tmp/boot/isolinux/isolinux.cfg</p>
<h1 id="将其中的以下这行修改："><a href="#将其中的以下这行修改：" class="headerlink" title="将其中的以下这行修改："></a>将其中的以下这行修改：</h1><p>append loglevel=3 user=docker console=ttyS0 console=tty0 nomodeset norestore base</p>
<h1 id="修改为：（其实就是加了tz的启动参数），然后保存"><a href="#修改为：（其实就是加了tz的启动参数），然后保存" class="headerlink" title="修改为：（其实就是加了tz的启动参数），然后保存"></a>修改为：（其实就是加了tz的启动参数），然后保存</h1><p>append tz=CST-8 loglevel=3 user=docker console=ttyS0 console=tty0 nomodeset norestore base</p>
<h1 id="接着你必须在ubuntu环境下重新制作ISO文件，你可以利用docker跑一个ubuntu，哈哈，假设你将boot2docker目录copy到了ubuntu的-src-目录下，那么接着这么做"><a href="#接着你必须在ubuntu环境下重新制作ISO文件，你可以利用docker跑一个ubuntu，哈哈，假设你将boot2docker目录copy到了ubuntu的-src-目录下，那么接着这么做" class="headerlink" title="接着你必须在ubuntu环境下重新制作ISO文件，你可以利用docker跑一个ubuntu，哈哈，假设你将boot2docker目录copy到了ubuntu的/src/目录下，那么接着这么做"></a>接着你必须在ubuntu环境下重新制作ISO文件，你可以利用docker跑一个ubuntu，哈哈，假设你将boot2docker目录copy到了ubuntu的/src/目录下，那么接着这么做</h1><h1 id="安装xorriso命令"><a href="#安装xorriso命令" class="headerlink" title="安装xorriso命令"></a>安装xorriso命令</h1><p>apt-get install xorriso</p>
<h1 id="构建ISO映射"><a href="#构建ISO映射" class="headerlink" title="构建ISO映射"></a>构建ISO映射</h1><p>xorriso -as mkisofs -J -R -V boot2docker -no-emul-boot -boot-load-size 4 -boot-info-table -b boot/isolinux/isolinux.bin -c boot/isolinux/boot.cat -o /boot2docker.iso /src/</p>
<h1 id="这样就生成了-boot2docker-iso文件，最后你就可以替换到VM的启动ISO文件了，然后重启VM了"><a href="#这样就生成了-boot2docker-iso文件，最后你就可以替换到VM的启动ISO文件了，然后重启VM了" class="headerlink" title="这样就生成了/boot2docker.iso文件，最后你就可以替换到VM的启动ISO文件了，然后重启VM了"></a>这样就生成了/boot2docker.iso文件，最后你就可以替换到VM的启动ISO文件了，然后重启VM了</h1><p>boot2docker restart</p>
<h1 id="最后你必须设置你的VM为正确的时间，使用date-s-命令，最后用date命令查看，你就能看到CST时区的正确时间了"><a href="#最后你必须设置你的VM为正确的时间，使用date-s-命令，最后用date命令查看，你就能看到CST时区的正确时间了" class="headerlink" title="最后你必须设置你的VM为正确的时间，使用date -s 命令，最后用date命令查看，你就能看到CST时区的正确时间了"></a>最后你必须设置你的VM为正确的时间，使用date -s 命令，最后用date命令查看，你就能看到CST时区的正确时间了</h1><p>Sun Mar 30 00:27:13 CST 2014</p>
<h1 id="对于你启动的container，你都必须重新设置TZ环境变量，否则即使VM是CST-8，你的container还是UCT-00-00的时间"><a href="#对于你启动的container，你都必须重新设置TZ环境变量，否则即使VM是CST-8，你的container还是UCT-00-00的时间" class="headerlink" title="对于你启动的container，你都必须重新设置TZ环境变量，否则即使VM是CST-8，你的container还是UCT +00:00的时间"></a>对于你启动的container，你都必须重新设置TZ环境变量，否则即使VM是CST-8，你的container还是UCT +00:00的时间</h1><p>export TZ=’CST-8’</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42</p>
<h1 id="首先你需要将boot2docker-iso文件mount到一个目录下-1"><a href="#首先你需要将boot2docker-iso文件mount到一个目录下-1" class="headerlink" title="首先你需要将boot2docker.iso文件mount到一个目录下"></a>首先你需要将boot2docker.iso文件mount到一个目录下</h1><p>hdiutil mount ~/.boot2docker/boot2docker.iso</p>
<h1 id="系统会mount到-Volumes-boot2docker目录下，然后你最好将这下面的东西copy出来到一个另外的目录，这样我们好制作一张新的ISO-1"><a href="#系统会mount到-Volumes-boot2docker目录下，然后你最好将这下面的东西copy出来到一个另外的目录，这样我们好制作一张新的ISO-1" class="headerlink" title="系统会mount到/Volumes/boot2docker目录下，然后你最好将这下面的东西copy出来到一个另外的目录，这样我们好制作一张新的ISO"></a>系统会mount到/Volumes/boot2docker目录下，然后你最好将这下面的东西copy出来到一个另外的目录，这样我们好制作一张新的ISO</h1><p>cp -r /Volumes/boot2docker/* ~/tmp/</p>
<h1 id="接着我们修改以下文件-1"><a href="#接着我们修改以下文件-1" class="headerlink" title="接着我们修改以下文件"></a>接着我们修改以下文件</h1><p>vi ~/tmp/boot/isolinux/isolinux.cfg</p>
<h1 id="将其中的以下这行修改：-1"><a href="#将其中的以下这行修改：-1" class="headerlink" title="将其中的以下这行修改："></a>将其中的以下这行修改：</h1><p>append loglevel=3 user=docker console=ttyS0 console=tty0 nomodeset norestore base</p>
<h1 id="修改为：（其实就是加了tz的启动参数），然后保存-1"><a href="#修改为：（其实就是加了tz的启动参数），然后保存-1" class="headerlink" title="修改为：（其实就是加了tz的启动参数），然后保存"></a>修改为：（其实就是加了tz的启动参数），然后保存</h1><p>append tz=CST-8 loglevel=3 user=docker console=ttyS0 console=tty0 nomodeset norestore base</p>
<h1 id="接着你必须在ubuntu环境下重新制作ISO文件，你可以利用docker跑一个ubuntu，哈哈，假设你将boot2docker目录copy到了ubuntu的-src-目录下，那么接着这么做-1"><a href="#接着你必须在ubuntu环境下重新制作ISO文件，你可以利用docker跑一个ubuntu，哈哈，假设你将boot2docker目录copy到了ubuntu的-src-目录下，那么接着这么做-1" class="headerlink" title="接着你必须在ubuntu环境下重新制作ISO文件，你可以利用docker跑一个ubuntu，哈哈，假设你将boot2docker目录copy到了ubuntu的/src/目录下，那么接着这么做"></a>接着你必须在ubuntu环境下重新制作ISO文件，你可以利用docker跑一个ubuntu，哈哈，假设你将boot2docker目录copy到了ubuntu的/src/目录下，那么接着这么做</h1><h1 id="安装xorriso命令-1"><a href="#安装xorriso命令-1" class="headerlink" title="安装xorriso命令"></a>安装xorriso命令</h1><p>apt-get install xorriso</p>
<h1 id="构建ISO映射-1"><a href="#构建ISO映射-1" class="headerlink" title="构建ISO映射"></a>构建ISO映射</h1><p>xorriso -as mkisofs -J -R -V boot2docker -no-emul-boot -boot-load-size 4 -boot-info-table -b boot/isolinux/isolinux.bin -c boot/isolinux/boot.cat -o /boot2docker.iso /src/</p>
<h1 id="这样就生成了-boot2docker-iso文件，最后你就可以替换到VM的启动ISO文件了，然后重启VM了-1"><a href="#这样就生成了-boot2docker-iso文件，最后你就可以替换到VM的启动ISO文件了，然后重启VM了-1" class="headerlink" title="这样就生成了/boot2docker.iso文件，最后你就可以替换到VM的启动ISO文件了，然后重启VM了"></a>这样就生成了/boot2docker.iso文件，最后你就可以替换到VM的启动ISO文件了，然后重启VM了</h1><p>boot2docker restart</p>
<h1 id="最后你必须设置你的VM为正确的时间，使用date-s-命令，最后用date命令查看，你就能看到CST时区的正确时间了-1"><a href="#最后你必须设置你的VM为正确的时间，使用date-s-命令，最后用date命令查看，你就能看到CST时区的正确时间了-1" class="headerlink" title="最后你必须设置你的VM为正确的时间，使用date -s 命令，最后用date命令查看，你就能看到CST时区的正确时间了"></a>最后你必须设置你的VM为正确的时间，使用date -s 命令，最后用date命令查看，你就能看到CST时区的正确时间了</h1><p>Sun Mar 30 00:27:13 CST 2014</p>
<h1 id="对于你启动的container，你都必须重新设置TZ环境变量，否则即使VM是CST-8，你的container还是UCT-00-00的时间-1"><a href="#对于你启动的container，你都必须重新设置TZ环境变量，否则即使VM是CST-8，你的container还是UCT-00-00的时间-1" class="headerlink" title="对于你启动的container，你都必须重新设置TZ环境变量，否则即使VM是CST-8，你的container还是UCT +00:00的时间"></a>对于你启动的container，你都必须重新设置TZ环境变量，否则即使VM是CST-8，你的container还是UCT +00:00的时间</h1><p>export TZ=’CST-8’</p>
<p>第三个问题暂时无法解决（可能需要编辑底层的LXC配置文件）。</p>
<p>docker的限制以及后续的一些想法</p>
<p>docker其实还是有一些限制的：</p>
<p>要求你的环境是Linux的，而且内核必须很新（&gt;= 2.6.27 (29)），这其实是LXC本身的限制，和docker无关<br>docker的Container目前host是不能修改的，当然有解决方案（dnsmasq）<br>docker的Container也暂时无法指定静态IP<br>用docker作为开发环境甚至是生产环境其实还有很多地方值得尝试：</p>
<p>在团队内部构建本地的仓库，标准化所有的开发环境，使得团队的新人可以快速上手<br>在生产环境部署docker，这其实是PAAS的虚拟化和自动化的一种方式，利用LXC和Docker能够更便捷地实施PAAS<br>尝试用docker做分布式集群模拟和测试，成本会更加低廉，更加容器维护</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/03/05/docker-develop/" data-id="cj4quikvq0003ne5s7691wfo7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/03/05/spark/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Spark：一个高效的分布式计算系统
        
      </div>
    </a>
  
  
    <a href="/2016/03/05/norm/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">创业公司的这些问题…其实是常态</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Books/">Books</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Life/">Life</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Movie/">Movie</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Objective-C/">Objective-C</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vps/">Vps</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web/">Web</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Work/">Work</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/npm/">npm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/性能/">性能</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/性能优化/">性能优化</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Books/">Books</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Debian/">Debian</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Digitalocean/">Digitalocean</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Dropbox/">Dropbox</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/FinalSpeed/">FinalSpeed</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Life/">Life</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Meeting/">Meeting</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Movie/">Movie</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Shadowsocks/">Shadowsocks</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TV/">TV</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ubuntu/">Ubuntu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vps/">Vps</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vultr/">Vultr</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Work/">Work</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ftp/">ftp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/next/">next</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sidebar/">sidebar</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/后端开发/">后端开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/安全/">安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/极路由/">极路由</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/爬虫/">爬虫</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/美剧/">美剧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/自动发布/">自动发布</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/词/">词</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/黑客/">黑客</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Books/" style="font-size: 10px;">Books</a> <a href="/tags/Debian/" style="font-size: 10px;">Debian</a> <a href="/tags/Digitalocean/" style="font-size: 10px;">Digitalocean</a> <a href="/tags/Dropbox/" style="font-size: 10px;">Dropbox</a> <a href="/tags/FinalSpeed/" style="font-size: 10px;">FinalSpeed</a> <a href="/tags/Life/" style="font-size: 10px;">Life</a> <a href="/tags/Meeting/" style="font-size: 10px;">Meeting</a> <a href="/tags/Movie/" style="font-size: 10px;">Movie</a> <a href="/tags/Python/" style="font-size: 13.33px;">Python</a> <a href="/tags/Shadowsocks/" style="font-size: 16.67px;">Shadowsocks</a> <a href="/tags/TV/" style="font-size: 10px;">TV</a> <a href="/tags/Ubuntu/" style="font-size: 10px;">Ubuntu</a> <a href="/tags/Vps/" style="font-size: 20px;">Vps</a> <a href="/tags/Vultr/" style="font-size: 10px;">Vultr</a> <a href="/tags/Work/" style="font-size: 10px;">Work</a> <a href="/tags/ftp/" style="font-size: 10px;">ftp</a> <a href="/tags/hexo/" style="font-size: 13.33px;">hexo</a> <a href="/tags/next/" style="font-size: 10px;">next</a> <a href="/tags/python/" style="font-size: 10px;">python</a> <a href="/tags/sidebar/" style="font-size: 10px;">sidebar</a> <a href="/tags/后端开发/" style="font-size: 10px;">后端开发</a> <a href="/tags/安全/" style="font-size: 10px;">安全</a> <a href="/tags/极路由/" style="font-size: 10px;">极路由</a> <a href="/tags/爬虫/" style="font-size: 13.33px;">爬虫</a> <a href="/tags/美剧/" style="font-size: 10px;">美剧</a> <a href="/tags/自动发布/" style="font-size: 10px;">自动发布</a> <a href="/tags/词/" style="font-size: 10px;">词</a> <a href="/tags/黑客/" style="font-size: 10px;">黑客</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">October 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">August 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">March 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/03/05/spark/">Spark：一个高效的分布式计算系统</a>
          </li>
        
          <li>
            <a href="/2016/03/05/docker-develop/">利用Docker构建开发环境</a>
          </li>
        
          <li>
            <a href="/2016/03/05/norm/">创业公司的这些问题…其实是常态</a>
          </li>
        
          <li>
            <a href="/2016/02/28/mac-ubuntu-finalspeed/">FinalSpeed搭建配置</a>
          </li>
        
          <li>
            <a href="/2016/02/25/python-mysql/">Python操作Mysql</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>