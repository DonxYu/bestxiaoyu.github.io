<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="Flux RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Rechercher"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-你不是Google，一语点醒技术人" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/14/你不是Google，一语点醒技术人/" class="article-date">
  <time datetime="2017-06-14T06:15:11.000Z" itemprop="datePublished">2017-06-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="你不是Google，一语点醒技术人"><a href="#你不是Google，一语点醒技术人" class="headerlink" title="你不是Google，一语点醒技术人"></a>你不是Google，一语点醒技术人</h1><p>软件工程师总是着迷于荒唐古怪的事。我们看起来似乎很理性，但在面对技术选型时，总是陷入抓狂——从 Hacker News 到各种博客，像一只飞蛾一样，来回折腾，最后精疲力尽，无助地飞向一团亮光，跪倒在它的前面——那就是我们一直在寻找的东西。<br>真正理性的人不是这样做决定的。不过工程师一贯如此，比如决定是否使用 MapReduce。<br>Joe Hellerstein 在他的大学数据库教程视频中说道：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">世界上只有差不多 5 个公司需要运行这么大规模的作业。至于其他公司……他们使用了所有的 IO 来实现不必要的容错。在 2000 年代，人们狂热地追随着 Google：“我们要做 Google 做过的每一件事，因为我们也运行着世界上最大的互联网数据服务。”</div></pre></td></tr></table></figure></p>
<p>超出实际需求的容错没有什么问题，但我们却为此付出了的惨重的代价：不仅增加了 IO，还有可能让原先成熟的系统——包含了事务、索引和查询优化器——变得破碎不堪。这是一个多么严重的历史倒退！有多少个 Hadoop 用户是有意识地做出这种决定的？有多少人知道他们的决定到底是不是一个明智之举？<br>MapReduce 已经成为一个众矢之的，那些盲目崇拜者也意识到事情不对劲。但这种情况却普遍存在：虽然你使用了大公司的技术，但你的情况却与他们大不一样，而且你的决定并没有经过深思熟虑，你只是习以为常地认为，模仿巨头公司就一定也能给你带来同样的财富。<br>是的，这又是一篇劝大家“不要盲目崇拜”的文章。不过这次我列出了一长串有用的清单，或许能够帮助你们做出更好的决定。</p>
<p><strong>很酷的技术？UNPHAT</strong><br>如果你还在使用 Google 搜索新技术来重建你的软件架构，那么我建议你不要再这么做了。相反，你可以考虑应用 UNPHAT 原则。<br>    1    在彻底了解（<strong>Understand</strong>）你的问题之前，不要急着去寻找解决方案。你的目标应该是在问题领域内“解决”问题，而不是在方案领域内解决问题。<br>    2    列出（<strong>eNumerate</strong>）多种方案，不要只把眼睛盯在你最喜欢的方案上。<br>    3    选择一个候选方案，并阅读相关论文（<strong>Paper</strong>）。<br>    4    了解候选方案的产生背景（<strong>Historical context</strong>）。<br>    5    比较优点（<strong>Advantages</strong>）和缺点，扬长避短。<br>    6    思考（<strong>Think</strong>）！冷静地思考候选方案是否适合用于解决你的问题。要出现怎样异常的情况才会让你改变注意？例如，数据要少到什么程度才会让你打消使用 Hadoop 的念头？</p>
<p><strong>你不是 Amazon</strong><br>UNPHAT 原则十分直截了当。最近我与一个公司有过一次对话，这个公司打算在一个读密集的系统里使用 Cassandra，他们的数据是在夜间加载到系统里的。<br>他们阅读了 Dynamo 的相关论文，并且知道 Cassandra 是最接近 Dynamo 的一个产品。我们知道，这些分布式数据库优先保证写可用性（Amazon 是不会让“添加到购物车”这种操作出现失败的）。为了达到这个目的，他们在一致性以及几乎所有在传统 RDBMS 中出现过的特性上做出了妥协。但这家公司其实没有必要优先考虑写可用性，因为他们每天只有一次写入操作，只是数据量比较大。<br>他们之所以考虑使用 Cassandra，是因为 PostgreSQL 查询需要耗费几分钟的时间。他们认为是硬件的问题，经过排查，我们发现数据表里有 5000 万条数据，每条数据最多 80 个字节。如果从 SSD 上整块地读取所有数据大概需要 5 秒钟，这个不算快，但比起实际的查询，它要快上两个数量级。<br>我真的很想多问他们几个问题（了解问题！），在问题变得愈加严重时，我为他们准备了 5 个方案（列出多个候选方案！），不过很显然，Cassandra 对于他们来说完全是一个错误的方案。他们只需要耐心地做一些调优，比如对部分数据重新建模，或许可以考虑使用（当然也有可能没有）其他技术……但一定不是这种写高可用的键值存储系统，Amazon 当初创建 Cassandra 是用来解决他们的购物车问题的！</p>
<p><strong>你不是 LinkedIn</strong><br>我发现一个学生创办的小公司居然在他们的系统里使用 Kafka，这让我感到很惊讶。因为据我所知，他们每天只有很少的事务需要处理——最好的情况下，一天最多只有几百个。这样的吞吐量几乎可以直接记在记事本上。<br>Kafka 被设计用于处理 LinkedIn 内部的吞吐量，那可是一个天文数字。即使是在几年前，这个数字已经达到了每天数万亿，在高峰时段每秒钟需要处理 1000 万个消息。不过 Kafka 也可以用于处理低吞吐量的负载，或许再低 10 个数量级？<br>或许工程师们在做决定时确实是基于他们的预期需求，并且也很了解 Kafka 的适用场景。但我猜测他们是抵挡不住社区对 Kafka 的追捧，并没有仔细想过 Kafka 是否适合他们。要知道，那可是 10 个数量级的差距！</p>
<p><strong>再一次，你不是 Amazon</strong><br>比 Amazon 的分布式数据库更为著名的是它的可伸缩架构模式，也就是面向服务架构。Werner Vogels 在 2006 年的一次访谈中指出，Amazon 在 2001 年时就意识到他们的前端需要横向伸缩，而面向服务架构有助于他们实现前端伸缩。工程师们面面相觑，最后只有少数几个工程师着手去做这件事情，而几乎没有人愿意将他们的静态网页拆分成小型的服务。<br>不过 Amazon 还是决定向 SOA 转型，他们当时有 7800 个员工和 30 亿美元的销售规模。<br>当然，并不是说你也要等到有 7800 个员工的时候才能转向 SOA……只是你要多想想，它真的能解决你的问题吗？你的问题的根源是什么？可以通过其他的方式解决它们吗？<br>如果你告诉我说，你那 50 个人的公司打算转向 SOA，那么我不禁感到疑惑：为什么很多大型的公司仍然在乐此不彼地使用具有模块化的大型单体应用？</p>
<p><strong>甚至 Google 也不是 Google</strong><br>使用 Hadoop 和 Spark 这样的大规模数据流引擎会非常有趣，但在很多情况下，传统的 DBMS 更适合当前的负载，有时候数据量小到可以直接放进内存。你是否愿意花 10,000 美金去购买 1TB 的内存？如果你有十亿个用户，每个用户仅能使用 1KB 的内存，所以你的投入远远不够。<br>或许你的负载大到需要把数据写回磁盘。那么你需要多少磁盘？你到底有多少数据量？Google 之所以要创建 GFS 和 MapReduce，是要解决整个 Web 的计算问题，比如重建整个 Web 的搜索索引。<br>或许你已经阅读过 GFS 和 MapReduce 的论文，Google 的部分问题在于吞吐量，而不是容量，他们之所以需要分布式的存储，是因为从磁盘读取字节流要花费太多的时间。那么你在 2017 年需要使用多少设备吞吐量？你一定不需要像 Google 那么大的吞吐量，所以你可能会考虑使用更好的设备。如果都用上 SSD 会给你增加多少成本？<br>或许你还想要伸缩性。但你有仔细算过吗，你的数据增长速度会快过 SSD 降价的速度吗？在你的数据撑爆所有的机器之前，你的业务会有多少增长？截止 2016 年，Stack Exchange 每天要处理 2 亿个请求，但是他们只用了 4 个 SQL Server，一个用于 Stack Overflow，一个用于其他用途，另外两个作为备份复本。<br>或许你在应用 UNPHAT 原则之后，仍然决定要使用 Hadoop 或 Spark。或许你的决定是对的，但关键的是你要用对工具。Google 非常明白这个道理，当他们意识到 MapReduce 不再适合用于构建索引之后，他们就不再使用它。</p>
<p><strong>先了解你的问题</strong><br>我所说的也不是什么新观点，不过或许 UNPHAT 对于你们来说已经足够了。如果你觉得还不够，可以听听 Rich Hickey 的演讲“吊床驱动开发（Hammock Driven Development）”，或者看看 Polya 的书《How to Solve It》， 或者学习一下 Hamming 的课程“The Art of Doing Science and Engineering”。我恳请你们一定要多思考！在尝试解决问题之前先对它们有充分的了解。最后送上 Polya 的一个金句名言：<br>回答一个你不了解的问题是愚蠢的，到达一个你不期望的终点是悲哀的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/06/14/你不是Google，一语点醒技术人/" data-id="cj4quyriu0000wj5sm2xuqp38" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-spark" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/05/spark/" class="article-date">
  <time datetime="2016-03-04T16:46:20.000Z" itemprop="datePublished">2016-03-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/05/spark/">Spark：一个高效的分布式计算系统</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>概述</p>
<p>什么是Spark</p>
<p>Spark是UC Berkeley AMP lab所开源的类Hadoop MapReduce的通用的并行计算框架，Spark基于map reduce算法实现的分布式计算，拥有Hadoop MapReduce所具有的优点；但不同于MapReduce的是Job中间输出和结果可以保存在内存中，从而不再需要读写HDFS，因此Spark能更好地适用于数据挖掘与机器学习等需要迭代的map reduce的算法。其架构如下图所示：spark-framwork<br>Spark与Hadoop的对比</p>
<p>Spark的中间数据放到内存中，对于迭代运算效率更高。<br>Spark更适合于迭代运算比较多的ML和DM运算。因为在Spark里面，有RDD的抽象概念。<br>Spark比Hadoop更通用。<br>Spark提供的数据集操作类型有很多种，不像Hadoop只提供了Map和Reduce两种操作。比如map, filter, flatMap, sample, groupByKey, reduceByKey, union, join, cogroup, mapValues, sort,partionBy等多种操作类型，Spark把这些操作称为Transformations。同时还提供Count, collect, reduce, lookup, save等多种actions操作。<br>这些多种多样的数据集操作类型，给给开发上层应用的用户提供了方便。各个处理节点之间的通信模型不再像Hadoop那样就是唯一的Data Shuffle一种模式。用户可以命名，物化，控制中间结果的存储、分区等。可以说编程模型比Hadoop更灵活。<br>不过由于RDD的特性，Spark不适用那种异步细粒度更新状态的应用，例如web服务的存储或者是增量的web爬虫和索引。就是对于那种增量修改的应用模型不适合。<br>容错性。<br>在分布式数据集计算时通过checkpoint来实现容错，而checkpoint有两种方式，一个是checkpoint data，一个是logging the updates。用户可以控制采用哪种方式来实现容错。<br>可用性。<br>Spark通过提供丰富的Scala, Java，Python API及交互式Shell来提高可用性。</p>
<p>Spark与Hadoop的结合</p>
<p>Spark可以直接对HDFS进行数据的读写，同样支持Spark on YARN。Spark可以与MapReduce运行于同集群中，共享存储资源与计算，数据仓库Shark实现上借用Hive，几乎与Hive完全兼容。<br>Spark的适用场景</p>
<p>Spark是基于内存的迭代计算框架，适用于需要多次操作特定数据集的应用场合。需要反复操作的次数越多，所需读取的数据量越大，受益越大，数据量小但是计算密集度较大的场合，受益就相对较小<br>由于RDD的特性，Spark不适用那种异步细粒度更新状态的应用，例如web服务的存储或者是增量的web爬虫和索引。就是对于那种增量修改的应用模型不适合。<br>总的来说Spark的适用面比较广泛且比较通用。<br>运行模式</p>
<p>本地模式<br>Standalone模式<br>Mesoes模式<br>yarn模式<br>Spark生态系统</p>
<p>Shark ( Hive on Spark): Shark基本上就是在Spark的框架基础上提供和Hive一样的H iveQL命令接口，为了最大程度的保持和Hive的兼容性，Shark使用了Hive的API来实现query Parsing和 Logic Plan generation，最后的PhysicalPlan execution阶段用Spark代替Hadoop MapReduce。通过配置Shark参数，Shark可以自动在内存中缓存特定的RDD，实现数据重用，进而加快特定数据集的检索。同时，Shark通过UDF用户自定义函数实现特定的数据分析学习算法，使得SQL数据查询和运算分析能结合在一起，最大化RDD的重复使用。<br>Spark streaming: 构建在Spark上处理Stream数据的框架，基本的原理是将Stream数据分成小的时间片断（几秒），以类似batch批量处理的方式来处理这小部分数据。Spark Streaming构建在Spark上，一方面是因为Spark的低延迟执行引擎（100ms+）可以用于实时计算，另一方面相比基于Record的其它处理框架（如Storm），RDD数据集更容易做高效的容错处理。此外小批量处理的方式使得它可以同时兼容批量和实时数据处理的逻辑和算法。方便了一些需要历史数据和实时数据联合分析的特定应用场合。<br>Bagel: Pregel on Spark，可以用Spark进行图计算，这是个非常有用的小项目。Bagel自带了一个例子，实现了Google的PageRank算法。<br>在业界的使用</p>
<p>Spark项目在2009年启动，2010年开源, 现在使用的有：Berkeley, Princeton, Klout, Foursquare, Conviva, Quantifind, Yahoo! Research &amp; others, 淘宝等，豆瓣也在使用Spark的python克隆版Dpark。<br>Spark核心概念</p>
<p>Resilient Distributed Dataset (RDD)弹性分布数据集</p>
<p>RDD是Spark的最基本抽象,是对分布式内存的抽象使用，实现了以操作本地集合的方式来操作分布式数据集的抽象实现。RDD是Spark最核心的东西，它表示已被分区，不可变的并能够被并行操作的数据集合，不同的数据集格式对应不同的RDD实现。RDD必须是可序列化的。RDD可以cache到内存中，每次对RDD数据集的操作之后的结果，都可以存放到内存中，下一个操作可以直接从内存中输入，省去了MapReduce大量的磁盘IO操作。这对于迭代运算比较常见的机器学习算法, 交互式数据挖掘来说，效率提升比较大。<br>RDD的特点：</p>
<p>它是在集群节点上的不可变的、已分区的集合对象。<br>通过并行转换的方式来创建如（map, filter, join, etc）。<br>失败自动重建。<br>可以控制存储级别（内存、磁盘等）来进行重用。<br>必须是可序列化的。<br>是静态类型的。<br>RDD的好处</p>
<p>RDD只能从持久存储或通过Transformations操作产生，相比于分布式共享内存（DSM）可以更高效实现容错，对于丢失部分数据分区只需根据它的lineage就可重新计算出来，而不需要做特定的Checkpoint。<br>RDD的不变性，可以实现类Hadoop MapReduce的推测式执行。<br>RDD的数据分区特性，可以通过数据的本地性来提高性能，这与Hadoop MapReduce是一样的。<br>RDD都是可序列化的，在内存不足时可自动降级为磁盘存储，把RDD存储于磁盘上，这时性能会有大的下降但不会差于现在的MapReduce。<br>RDD的存储与分区</p>
<p>用户可以选择不同的存储级别存储RDD以便重用。<br>当前RDD默认是存储于内存，但当内存不足时，RDD会spill到disk。<br>RDD在需要进行分区把数据分布于集群中时会根据每条记录Key进行分区（如Hash 分区），以此保证两个数据集在Join时能高效。<br>RDD的内部表示<br>在RDD的内部实现中每个RDD都可以使用5个方面的特性来表示：</p>
<p>分区列表（数据块列表）<br>计算每个分片的函数（根据父RDD计算出此RDD）<br>对父RDD的依赖列表<br>对key-value RDD的Partitioner【可选】<br>每个数据分片的预定义地址列表(如HDFS上的数据块的地址)【可选】<br>RDD的存储级别<br>RDD根据useDisk、useMemory、deserialized、replication四个参数的组合提供了11种存储级别：</p>
<pre><code>val NONE = new StorageLevel(false, false, false) 
val DISK_ONLY = new StorageLevel(true, false, false) 
val DISK_ONLY_2 = new StorageLevel(true, false, false, 2) 
val MEMORY_ONLY = new StorageLevel(false, true, true) 
val MEMORY_ONLY_2 = new StorageLevel(false, true, true, 2) 
val MEMORY_ONLY_SER = new StorageLevel(false, true, false) 
val MEMORY_ONLY_SER_2 = new StorageLevel(false, true, false, 2) 
val MEMORY_AND_DISK = new StorageLevel(true, true, true) 
val MEMORY_AND_DISK_2 = new StorageLevel(true, true, true, 2) 
val MEMORY_AND_DISK_SER = new StorageLevel(true, true, false) 
val MEMORY_AND_DISK_SER_2 = new StorageLevel(true, true, false, 2)               
</code></pre><p>RDD定义了各种操作，不同类型的数据由不同的RDD类抽象表示，不同的操作也由RDD进行抽实现。</p>
<p>RDD的生成</p>
<p>RDD有两种创建方式：<br>1、从Hadoop文件系统（或与Hadoop兼容的其它存储系统）输入（例如HDFS）创建。<br>2、从父RDD转换得到新RDD。<br>下面来看一从Hadoop文件系统生成RDD的方式，如：val file = spark.textFile(“hdfs://…”)，file变量就是RDD（实际是HadoopRDD实例），生成的它的核心代码如下：</p>
<pre><code>// SparkContext根据文件/目录及可选的分片数创建RDD, 这里我们可以看到Spark与Hadoop MapReduce很像 
// 需要InputFormat, Key、Value的类型，其实Spark使用的Hadoop的InputFormat, Writable类型。 
def textFile(path: String, minSplits: Int = defaultMinSplits): RDD[String] = { 
    hadoopFile(path, classOf[TextInputFormat], classOf[LongWritable], 
    classOf[Text], minSplits) .map(pair =&gt; pair._2.toString) }

// 根据Hadoop配置，及InputFormat等创建HadoopRDD  
new HadoopRDD(this, conf, inputFormatClass, keyClass, valueClass, minSplits)    

// SparkContext根据文件/目录及可选的分片数创建RDD, 这里我们可以看到Spark与Hadoop MapReduce很像 
// 需要InputFormat, Key、Value的类型，其实Spark使用的Hadoop的InputFormat, Writable类型。 
def textFile(path: String, minSplits: Int = defaultMinSplits): RDD[String] = { 
    hadoopFile(path, classOf[TextInputFormat], classOf[LongWritable], 
    classOf[Text], minSplits) .map(pair =&gt; pair._2.toString) }

// 根据Hadoop配置，及InputFormat等创建HadoopRDD  
new HadoopRDD(this, conf, inputFormatClass, keyClass, valueClass, minSplits)    
</code></pre><p>对RDD进行计算时，RDD从HDFS读取数据时与Hadoop MapReduce几乎一样的：</p>
<pre><code>// 根据hadoop配置和分片从InputFormat中获取RecordReader进行数据的读取。 
reader = fmt.getRecordReader(split.inputSplit.value, conf, Reporter.NULL)

val key: K = reader.createKey()
val value: V = reader.createValue()

//使用Hadoop MapReduce的RecordReader读取数据，每个Key、Value对以元组返回。
override def getNext() = {
try {
  finished = !reader.next(key, value)
} catch {
  case eof: EOFException =&gt;
    finished = true
}
  (key, value)
}

// 根据hadoop配置和分片从InputFormat中获取RecordReader进行数据的读取。 
reader = fmt.getRecordReader(split.inputSplit.value, conf, Reporter.NULL)

val key: K = reader.createKey()
val value: V = reader.createValue()

//使用Hadoop MapReduce的RecordReader读取数据，每个Key、Value对以元组返回。
override def getNext() = {
try {
  finished = !reader.next(key, value)
} catch {
  case eof: EOFException =&gt;
    finished = true
}
  (key, value)
}
</code></pre><p>RDD的转换与操作</p>
<p>对于RDD可以有两种计算方式：转换（返回值还是一个RDD）与操作（返回值不是一个RDD）。<br>转换(Transformations) (如：map, filter, groupBy, join等)，Transformations操作是Lazy的，也就是说从一个RDD转换生成另一个RDD的操作不是马上执行，Spark在遇到Transformations操作时只会记录需要这样的操作，并不会去执行，需要等到有Actions操作的时候才会真正启动计算过程进行计算。<br>操作(Actions) (如：count, collect, save等)，Actions操作会返回结果或把RDD数据写到存储系统中。Actions是触发Spark启动计算的动因。<br>下面使用一个例子来示例说明Transformations与Actions在Spark的使用。</p>
<pre><code>val sc = new SparkContext(master, &quot;Example&quot;, System.getenv(&quot;SPARK_HOME&quot;), 
    Seq(System.getenv(&quot;SPARK_TEST_JAR&quot;)))

val rdd_A = sc.textFile(hdfs://.....)
val rdd_B = rdd_A.flatMap((line =&gt; line.split(&quot;\\s+&quot;))).map(word =&gt; (word, 1))

val rdd_C = sc.textFile(hdfs://.....)
val rdd_D = rdd_C.map(line =&gt; (line.substring(10), 1))
val rdd_E = rdd_D.reduceByKey((a, b) =&gt; a + b)

val rdd_F = rdd_B.jion(rdd_E)

rdd_F.saveAsSequenceFile(hdfs://....)

val sc = new SparkContext(master, &quot;Example&quot;, System.getenv(&quot;SPARK_HOME&quot;), 
    Seq(System.getenv(&quot;SPARK_TEST_JAR&quot;)))

val rdd_A = sc.textFile(hdfs://.....)
val rdd_B = rdd_A.flatMap((line =&gt; line.split(&quot;\\s+&quot;))).map(word =&gt; (word, 1))

val rdd_C = sc.textFile(hdfs://.....)
val rdd_D = rdd_C.map(line =&gt; (line.substring(10), 1))
val rdd_E = rdd_D.reduceByKey((a, b) =&gt; a + b)

val rdd_F = rdd_B.jion(rdd_E)

rdd_F.saveAsSequenceFile(hdfs://....)
</code></pre><p>SparkTA11</p>
<p>Lineage（血统）</p>
<p>利用内存加快数据加载,在众多的其它的In-Memory类数据库或Cache类系统中也有实现，Spark的主要区别在于它处理分布式运算环境下的数据容错性（节点实效/数据丢失）问题时采用的方案。为了保证RDD中数据的鲁棒性，RDD数据集通过所谓的血统关系(Lineage)记住了它是如何从其它RDD中演变过来的。相比其它系统的细颗粒度的内存数据更新级别的备份或者LOG机制，RDD的Lineage记录的是粗颗粒度的特定数据转换（Transformation）操作（filter, map, join etc.)行为。当这个RDD的部分分区数据丢失时，它可以通过Lineage获取足够的信息来重新运算和恢复丢失的数据分区。这种粗颗粒的数据模型，限制了Spark的运用场合，但同时相比细颗粒度的数据模型，也带来了性能的提升。<br>RDD在Lineage依赖方面分为两种Narrow Dependencies与Wide Dependencies用来解决数据容错的高效性。Narrow Dependencies是指父RDD的每一个分区最多被一个子RDD的分区所用，表现为一个父RDD的分区对应于一个子RDD的分区或多个父RDD的分区对应于一个子RDD的分区，也就是说一个父RDD的一个分区不可能对应一个子RDD的多个分区。Wide Dependencies是指子RDD的分区依赖于父RDD的多个分区或所有分区，也就是说存在一个父RDD的一个分区对应一个子RDD的多个分区。对与Wide Dependencies，这种计算的输入和输出在不同的节点上，lineage方法对与输入节点完好，而输出节点宕机时，通过重新计算，这种情况下，这种方法容错是有效的，否则无效，因为无法重试，需要向上其祖先追溯看是否可以重试（这就是lineage，血统的意思），Narrow Dependencies对于数据的重算开销要远小于Wide Dependencies的数据重算开销。<br>容错</p>
<p>在RDD计算，通过checkpint进行容错，做checkpoint有两种方式，一个是checkpoint data，一个是logging the updates。用户可以控制采用哪种方式来实现容错，默认是logging the updates方式，通过记录跟踪所有生成RDD的转换（transformations）也就是记录每个RDD的lineage（血统）来重新计算生成丢失的分区数据。<br>资源管理与作业调度</p>
<p>Spark对于资源管理与作业调度可以使用Standalone(独立模式)，Apache Mesos及Hadoop YARN来实现。 Spark on Yarn在Spark0.6时引用，但真正可用是在现在的branch-0.8版本。Spark on Yarn遵循YARN的官方规范实现，得益于Spark天生支持多种Scheduler和Executor的良好设计，对YARN的支持也就非常容易，Spark on Yarn的大致框架图。 Spark架构图</p>
<p>让Spark运行于YARN上与Hadoop共用集群资源可以提高资源利用率。</p>
<p>编程接口</p>
<p>Spark通过与编程语言集成的方式暴露RDD的操作，类似于DryadLINQ和FlumeJava，每个数据集都表示为RDD对象，对数据集的操作就表示成对RDD对象的操作。Spark主要的编程语言是Scala，选择Scala是因为它的简洁性（Scala可以很方便在交互式下使用）和性能（JVM上的静态强类型语言）。<br>Spark和Hadoop MapReduce类似，由Master(类似于MapReduce的Jobtracker)和Workers(Spark的Slave工作节点)组成。用户编写的Spark程序被称为Driver程序，Dirver程序会连接master并定义了对各RDD的转换与操作，而对RDD的转换与操作通过Scala闭包(字面量函数)来表示，Scala使用Java对象来表示闭包且都是可序列化的，以此把对RDD的闭包操作发送到各Workers节点。 Workers存储着数据分块和享有集群内存，是运行在工作节点上的守护进程，当它收到对RDD的操作时，根据数据分片信息进行本地化数据操作，生成新的数据分片、返回结果或把RDD写入存储系统。 runtime<br>Scala</p>
<p>Spark使用Scala开发，默认使用Scala作为编程语言。编写Spark程序比编写Hadoop MapReduce程序要简单的多，SparK提供了Spark-Shell，可以在Spark-Shell测试程序。写SparK程序的一般步骤就是创建或使用(SparkContext)实例，使用SparkContext创建RDD，然后就是对RDD进行操作。如：</p>
<pre><code>val sc = new SparkContext(master, appName, [sparkHome], [jars]) 
val textFile = sc.textFile(&quot;hdfs://.....&quot;) 
textFile.map(....).filter(.....).....

val sc = new SparkContext(master, appName, [sparkHome], [jars]) 
val textFile = sc.textFile(&quot;hdfs://.....&quot;) 
textFile.map(....).filter(.....).....
</code></pre><p>Java</p>
<p>Spark支持Java编程，但对于使用Java就没有了Spark-Shell这样方便的工具，其它与Scala编程是一样的，因为都是JVM上的语言，Scala与Java可以互操作，Java编程接口其实就是对Scala的封装。如：</p>
<pre><code>JavaSparkContext sc = new JavaSparkContext(...);  
JavaRDD lines = ctx.textFile(&quot;hdfs://...&quot;); 
JavaRDD words = lines.flatMap( 
  new FlatMapFunction&lt;String, String&gt;() { 
     public Iterable call(String s) { 
        return Arrays.asList(s.split(&quot; &quot;)); 
     } 
   } 
);
</code></pre><p>   JavaSparkContext sc = new JavaSparkContext(…);<br>    JavaRDD lines = ctx.textFile(“hdfs://…”);<br>    JavaRDD words = lines.flatMap(<br>      new FlatMapFunction<string, string="">() {<br>         public Iterable call(String s) {<br>            return Arrays.asList(s.split(“ “));<br>         }<br>       }<br>    );</string,></p>
<p>Python</p>
<p>现在Spark也提供了Python编程接口，Spark使用py4j来实现python与java的互操作，从而实现使用python编写Spark程序。Spark也同样提供了pyspark，一个Spark的python shell，可以以交互式的方式使用Python编写Spark程序。 如：</p>
<pre><code>from pyspark import SparkContext 
sc = SparkContext(&quot;local&quot;, &quot;Job Name&quot;, pyFiles=[&apos;MyFile.py&apos;, &apos;lib.zip&apos;, &apos;app.egg&apos;]) 
words = sc.textFile(&quot;/usr/share/dict/words&quot;) 
words.filter(lambda w: w.startswith(&quot;spar&quot;)).take(5)


from pyspark import SparkContext 
sc = SparkContext(&quot;local&quot;, &quot;Job Name&quot;, pyFiles=[&apos;MyFile.py&apos;, &apos;lib.zip&apos;, &apos;app.egg&apos;]) 
words = sc.textFile(&quot;/usr/share/dict/words&quot;) 
words.filter(lambda w: w.startswith(&quot;spar&quot;)).take(5)
</code></pre><p>使用示例</p>
<p>Standalone模式</p>
<p>为方便Spark的推广使用，Spark提供了Standalone模式，Spark一开始就设计运行于Apache Mesos资源管理框架上，这是非常好的设计，但是却带了部署测试的复杂性。为了让Spark能更方便的部署和尝试，Spark因此提供了Standalone运行模式，它由一个Spark Master和多个Spark worker组成，与Hadoop MapReduce1很相似，就连集群启动方式都几乎是一样。<br>以Standalone模式运行Spark集群</p>
<p>下载Scala2.9.3，并配置SCALA_HOME<br>下载Spark代码（可以使用源码编译也可以下载编译好的版本）这里下载 编译好的版本（<a href="http://spark-project.org/download/spark-0.7.3-prebuilt-cdh4.tgz）" target="_blank" rel="external">http://spark-project.org/download/spark-0.7.3-prebuilt-cdh4.tgz）</a><br>解压spark-0.7.3-prebuilt-cdh4.tgz安装包<br>修改配置（conf/*） slaves: 配置工作节点的主机名 spark-env.sh：配置环境变量。</p>
<p>SCALA_HOME=/home/spark/scala-2.9.3<br>JAVA_HOME=/home/spark/jdk1.6.0_45<br>SPARK_MASTER_IP=spark1<br>SPARK_MASTER_PORT=30111<br>SPARK_MASTER_WEBUI_PORT=30118<br>SPARK_WORKER_CORES=2 SPARK_WORKER_MEMORY=4g<br>SPARK_WORKER_PORT=30333<br>SPARK_WORKER_WEBUI_PORT=30119<br>SPARK_WORKER_INSTANCES=1</p>
<p>SCALA_HOME=/home/spark/scala-2.9.3<br>JAVA_HOME=/home/spark/jdk1.6.0_45<br>SPARK_MASTER_IP=spark1<br>SPARK_MASTER_PORT=30111<br>SPARK_MASTER_WEBUI_PORT=30118<br>SPARK_WORKER_CORES=2 SPARK_WORKER_MEMORY=4g<br>SPARK_WORKER_PORT=30333<br>SPARK_WORKER_WEBUI_PORT=30119<br>SPARK_WORKER_INSTANCES=1</p>
<p>把Hadoop配置copy到conf目录下</p>
<p>在master主机上对其它机器做ssh无密码登录</p>
<p>把配置好的Spark程序使用scp copy到其它机器</p>
<p>在master启动集群</p>
<p>$SPARK_HOME/start-all.sh</p>
<p>$SPARK_HOME/start-all.sh</p>
<p>yarn模式</p>
<p>Spark-shell现在还不支持Yarn模式，使用Yarn模式运行，需要把Spark程序全部打包成一个jar包提交到Yarn上运行。目录只有branch-0.8版本才真正支持Yarn。<br>以Yarn模式运行Spark</p>
<p>下载Spark代码.</p>
<p>git clone git://github.com/mesos/spark </p>
<p>git clone git://github.com/mesos/spark </p>
<p>切换到branch-0.8</p>
<p>cd spark<br>git checkout -b yarn –track origin/yarn </p>
<p>cd spark<br>git checkout -b yarn –track origin/yarn </p>
<p>使用sbt编译Spark并</p>
<p>$SPARK_HOME/sbt/sbt </p>
<blockquote>
<p>package<br>assembly</p>
</blockquote>
<p>$SPARK_HOME/sbt/sbt </p>
<blockquote>
<p>package<br>assembly</p>
</blockquote>
<p>把Hadoop yarn配置copy到conf目录下</p>
<p>运行测试</p>
<p> SPARK_JAR=./core/target/scala-2.9.3/spark-core-assembly-0.8.0-SNAPSHOT.jar \<br>./run spark.deploy.yarn.Client –jar examples/target/scala-2.9.3/ \<br>–class spark.examples.SparkPi –args yarn-standalone</p>
<p> SPARK_JAR=./core/target/scala-2.9.3/spark-core-assembly-0.8.0-SNAPSHOT.jar \<br>./run spark.deploy.yarn.Client –jar examples/target/scala-2.9.3/ \<br>–class spark.examples.SparkPi –args yarn-standalone</p>
<p>使用Spark-shell</p>
<p>Spark-shell使用很简单，当Spark以Standalon模式运行后，使用$SPARK_HOME/spark-shell进入shell即可，在Spark-shell中SparkContext已经创建好了，实例名为sc可以直接使用，还有一个需要注意的是，在Standalone模式下，Spark默认使用的调度器的FIFO调度器而不是公平调度，而Spark-shell作为一个Spark程序一直运行在Spark上，其它的Spark程序就只能排队等待，也就是说同一时间只能有一个Spark-shell在运行。<br>在Spark-shell上写程序非常简单，就像在Scala Shell上写程序一样。</p>
<pre><code>scala&gt; val textFile = sc.textFile(&quot;hdfs://hadoop1:2323/user/data&quot;) 
textFile: spark.RDD[String] = spark.MappedRDD@2ee9b6e3

scala&gt; textFile.count() // Number of items in this RDD
res0: Long = 21374

scala&gt; textFile.first() // First item in this RDD
res1: String = # Spark

scala&gt; val textFile = sc.textFile(&quot;hdfs://hadoop1:2323/user/data&quot;) 
textFile: spark.RDD[String] = spark.MappedRDD@2ee9b6e3

scala&gt; textFile.count() // Number of items in this RDD
res0: Long = 21374

scala&gt; textFile.first() // First item in this RDD
res1: String = # Spark
</code></pre><p>编写Driver程序</p>
<p>在Spark中Spark程序称为Driver程序，编写Driver程序很简单几乎与在Spark-shell上写程序是一样的，不同的地方就是SparkContext需要自己创建。如WorkCount程序如下：</p>
<p>import spark.SparkContext<br>import SparkContext._</p>
<p>object WordCount {<br>  def main(args: Array[String]) {<br>    if (args.length ==0 ){<br>      println(“usage is org.test.WordCount <master>“)<br>    }<br>    println(“the args: “)<br>    args.foreach(println)</master></p>
<pre><code>val hdfsPath = &quot;hdfs://hadoop1:8020&quot;

// create the SparkContext， args(0)由yarn传入appMaster地址
val sc = new SparkContext(args(0), &quot;WrodCount&quot;,
System.getenv(&quot;SPARK_HOME&quot;), Seq(System.getenv(&quot;SPARK_TEST_JAR&quot;)))

val textFile = sc.textFile(hdfsPath + args(1))

val result = textFile.flatMap(line =&gt; line.split(&quot;\\s+&quot;))
    .map(word =&gt; (word, 1)).reduceByKey(_ + _)

result.saveAsTextFile(hdfsPath + args(2))
</code></pre><p>  }<br>}<br>import spark.SparkContext<br>import SparkContext._</p>
<p>object WordCount {<br>  def main(args: Array[String]) {<br>    if (args.length ==0 ){<br>      println(“usage is org.test.WordCount <master>“)<br>    }<br>    println(“the args: “)<br>    args.foreach(println)</master></p>
<pre><code>val hdfsPath = &quot;hdfs://hadoop1:8020&quot;

// create the SparkContext， args(0)由yarn传入appMaster地址
val sc = new SparkContext(args(0), &quot;WrodCount&quot;,
System.getenv(&quot;SPARK_HOME&quot;), Seq(System.getenv(&quot;SPARK_TEST_JAR&quot;)))

val textFile = sc.textFile(hdfsPath + args(1))

val result = textFile.flatMap(line =&gt; line.split(&quot;\\s+&quot;))
    .map(word =&gt; (word, 1)).reduceByKey(_ + _)

result.saveAsTextFile(hdfsPath + args(2))
</code></pre><p>  }<br>}</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/03/05/spark/" data-id="cj4quikx9001cne5s892c0rmn" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-docker-develop" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/05/docker-develop/" class="article-date">
  <time datetime="2016-03-04T16:45:31.000Z" itemprop="datePublished">2016-03-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Docker/">Docker</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/05/docker-develop/">利用Docker构建开发环境</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近接触PAAS相关的知识，在研发过程中开始使用Docker搭建了自己完整的开发环境，感觉生活在PAAS时代的程序员真是幸福，本文会简要介绍下Docker是什么，如何利用Docker来搭建自己的开发环境（本文主要是面向Mac OS X），以及期间所遇到的一些坑和解决方案。（本文会要求你对PAAS、LXC、CGroup、AUFS有一定的了解基础，请自行Google ）</p>
<p>大背景–虚拟化技术历史</p>
<p>计算机虚拟化技术由来已久，从硬件仿真到全虚拟化，再到准虚拟化和操作系统虚拟化，各种技术粉墨登场，种类繁多，说实在的有点眼花缭乱和复杂；但用户的核心诉求一直是比较简单的，降低信息技术（IT）的运营成本，提高资源利用率，提高安全性和可靠性等等；虽说用户的核心诉求比较简单，但每个时代的需求场景却是不同的。在大型机时代，虚拟化技术被用来支持多个用户能够同时使用大型机，在x86架构时代，随着企业服务的大规模部署，虚拟化技术主要是用来提高企业资源的利用率，而现如今，随着云计算时代的到来，人们对应用的安全性、隔离性越来越高，对于部署的标准化以及虚拟机的性能要求越来越高。现如今，一种叫Linux容器的虚拟化技术逐渐得到广泛的应用，它的优点有许多，本文不一一赘述，有太多的文章可以参考。</p>
<p>什么是Docker？</p>
<p>docker的英文本意是码头工人，也就是搬运工，这种搬运工搬运的是集装箱（Container），集装箱里面装的可不是商品货物，而是任意类型的App，Docker把App（叫Payload）装在Container内，通过Linux Container技术的包装将App变成一种标准化的、可移植的、自管理的组件，这种组件可以在你的latop上开发、调试、运行，最终非常方便和一致地运行在production环境下。</p>
<p>Docker的核心底层技术是LXC（Linux Container），Docker在其上面加了薄薄的一层，添加了许多有用的功能。这篇stackoverflow上的问题和答案很好地诠释了Docker和LXC的区别，能够让你更好的了解什么是Docker， 简单翻译下就是以下几点：</p>
<p>Docker提供了一种可移植的配置标准化机制，允许你一致性地在不同的机器上运行同一个Container；而LXC本身可能因为不同机器的不同配置而无法方便地移植运行；<br>Docker以App为中心，为应用的部署做了很多优化，而LXC的帮助脚本主要是聚焦于如何机器启动地更快和耗更少的内存；<br>Docker为App提供了一种自动化构建机制（Dockerfile），包括打包，基础设施依赖管理和安装等等；<br>Docker提供了一种类似git的Container版本化的机制，允许你对你创建过的容器进行版本管理，依靠这种机制，你还可以下载别人创建的Container，甚至像git那样进行合并；<br>Docker Container是可重用的，依赖于版本化机制，你很容易重用别人的Container（叫Image），作为基础版本进行扩展；<br>Docker Container是可共享的，有点类似github一样，Docker有自己的INDEX，你可以创建自己的Docker用户并上传和下载Docker Image；<br>Docker提供了很多的工具链，形成了一个生态系统；这些工具的目标是自动化、个性化和集成化，包括对PAAS平台的支持等；<br>那么Docker有什么用呢？对于运维来说，Docker提供了一种可移植的标准化部署过程，使得规模化、自动化、异构化的部署成为可能甚至是轻松简单的事情；而对于开发者来说，Docker提供了一种开发环境的管理方法，包括映像、构建、共享等功能，而后者是本文的主题。</p>
<p>Docker的安装和构成</p>
<p>Docker官方本身提供了非常具体的安装教程，这里不说具体的安装过程，请参考Docker安装（Mac系统），重要的是描述下原理和安装完成后的结构，好对Docker更好的了解。 由于LXC本身不支持Mac内核，因此需要跑一个VirtualBox虚拟机（TinyCoreLinux）来安装，幸好Docker社区提供了一个非常方便的工具boot2docker（其实就是一个VBoxManage的包装shell脚本），用于安装Mac下的整个Docker环境。具体的结构如下：</p>
<p>docker-install</p>
<p>如图所示，安装完成后，具体情况如下：</p>
<p>在Mac的home目录~/.boot2docker下创建了虚拟机所需要的文件，其中boot2docker.iso是虚拟机映像，这是一个由CD-ROM引导的TinyCoreLinux系统；而boot2docker-vm.vmdk文件则是你的虚拟机磁盘，你所有的持久化数据都存放在这里，包括docker创建的lxc容器等文件。<br>在Mac下，docker被分为客户端docker-client和服务端docker-daemon两部分，如果是在linux（比如ubuntu），实际上则是同一个可执行文件同时充当客户端和服务端。docker-daemon可以监听unix scoket，也可以在tcp socket（默认端口为4234），docker-client会通过一个叫DOCKER_HOST的环境变量读取服务地址和端口，因此你应该在你的bash_profile文件里面添加这么一行：</p>
<p>export DOCKER_HOST=tcp://127.0.0.1:4243</p>
<p>1<br>2<br>export DOCKER_HOST=tcp://127.0.0.1:4243</p>
<p>docker-daemon跑在虚拟机上，这个程序实际上就是接收docker-client发送过来的消息命令，创建、启动和销毁lxc容器，以及docker本身的版本管理、映像存储等等 运行你的第一个docker容器 安装完成后，就差不多可以开始创建和运行docker容器了，在这之前，你首先得下载一个Image，什么是Image？我们先来了解docker的2个基础概念：Image和Container。</p>
<p>Container和Image 在Docker的世界里，Image是指一个只读的层（Layer），这里的层是AUFS里的概念，最直观的方式就是看一下docker官方给出的图：</p>
<p>docker-filesystems-multilayer</p>
<p>Docker使用了一种叫AUFS的文件系统，这种文件系统可以让你一层一层地叠加修改你的文件，最底下的文件系统是只读的，如果需要修改文件，AUFS会增加一个可写的层（Layer），这样有很多好处，例如不同的Container可以共享底层的只读文件系统（同一个Kernel），使得你可以跑N多个Container而不至于你的硬盘被挤爆了！这个只读的层就是Image！而如你所看到的，一个可写的层就是Container。</p>
<p>那Image和Container的区别是什么？很简单，他们的区别仅仅是一个是只读的层，一个是可写的层，你可以使用docker commit 命令，将你的Container变成一个Image，也就是提交你所运行的Container的修改内容，变成一个新的只读的Image，这非常类似于git commit命令，感觉真棒！</p>
<p>实际上这就是Docker对Container映像的版本管理基石，AUFS文件系统实在是太美妙了，更多细节可以参考DotCloud的这篇文章。</p>
<p>运行和退出</p>
<p>在了解了Image和Container的概念后，我们可以开始下载一个Image，Docker的好处就是提供了一个类似github的Image仓库管理，你可以非常方便pull别人的Image下来运行，例如，我们可以下载一个ubuntu Image：</p>
<p>docker pull ubuntu:13.10 </p>
<p>1<br>2<br>docker pull ubuntu:13.10 </p>
<p>这里的13.10是一个Tag，类似于git的tag，这里的tag可以为你制定一个ubuntu的版本。下载完成后，执行docker images命令可以列出你已经下载或者自己构建的image：（请允许我使用可爱的马赛克 :) ）</p>
<p>QQ20140322-1</p>
<p>你可以看到ubuntu:13.10的大小为178MB，以及它的IMAGE ID。 现在我们开始运行一个Container，命令很简单，例如我们想运行一个执行Shell终端的Container：</p>
<p>QQ20140322-2</p>
<p>如你看到的，你已经进入到一个Shell里面，可以执行你想执行的任何命令，就和在ubuntu里面一样，进去后默认是在根目录/下，可以看到经典的unix/linux目录结构，以及你所运行的bash版本等信息。你可以给你的Container定一个名字，通过–name选项，例如这里命名了shell，日后你就可以直接用这个名字引用Contanier。</p>
<p>退出一个Container也很简单，你直接exit就好了。 其他更多的命令这里不做赘述，因为官方的文档已经非常全面，这里只是给一个直观的初步印象。下面进入主题。</p>
<p>利用Docker搭建开发环境</p>
<p>我们先看看程序员在搭建开发环境时遇到的一些问题：</p>
<p>软件安装麻烦，比如很多公司都使用redhat，一般开发人员又不给root，安装一个nginx或者是mysql都得自己下载编译安装 权限问题，没有root，一些软件无法运行，例如dnsmasq；<br>没有root，无法修改hosts，无法netstat -nptl，无法tcpdump，无法iptable<br>隔离性差，例如不同的开发人员如果在同一台主机环境下共享开发，虽然是用户隔离，但端口如果不规范可能会冲突；同一个Mysql如果权限管理不好很有可能误删别人的数据<br>可移植性差，例如和生产环境不一致，开发人员之间也无法共享；更严重的情况是当有新人入职时，通常需要又折腾一遍开发环境，无法快速搭建<br>这些问题可以通过在本地搭建虚拟机来解决，但虚拟机是一个很笨重的解决方案，Docker是一个非常轻量级的方案，而且还拥有虚拟机没有的一些功能，例如标准化Image，Image共享等，更重要的是，利用Docker，你可以运行非常多的容器，在你的Mac下搭建一个分布式的开发环境根本不是什么大的问题，而且对内存、磁盘和cpu的消耗相比传统的虚拟机要低许多，这些都要归功于AUFS和LXC这两大神奇的技术。</p>
<p>构建基础Image</p>
<p>想要搭建一个节省磁盘空间和扩展性良好的开发环境，最重要的第一步就是构建一个基础性的Image，比如你的主要开发语言是Ruby，那么你肯定需要一个已经安装好以下工具的基础Image：</p>
<p>ruby<br>bundler<br>gem<br>然后在此基础上，你可以扩展这个基础的Image（下面叫base）为不同的开发环境，例如rails，或者是nats。当然，你的这个base也可以从别人的Image扩展而来，还记得我们刚刚pull下来的ubuntu:13.10这个Image吗？你可以从这个Image扩展开始构建你的base，如何做呢？Docker提供了一种标准化的DSL方式，你只需要编写一个Dockerfile，运行docker build指令，就可以构建你自己的Image，这有点像Makefile和make命令一样，只是大家要构建的内容和构建语言不同。</p>
<p>Dockerfile的语法请参考Dockerfile Reference，这里给出上面提到的Ruby开发的base Dockerfile示例：</p>
<p>FROM ubuntu:13.10<br>RUN apt-get update<br>RUN apt-get install -y ruby ruby-dev gem<br>RUN gem install bundler </p>
<p>1<br>2<br>3<br>4<br>5<br>FROM ubuntu:13.10<br>RUN apt-get update<br>RUN apt-get install -y ruby ruby-dev gem<br>RUN gem install bundler </p>
<p>这里只用到了很简单的2个指令：FROM和RUN，FROM指定了我们要扩展的Image，RUN指定我们要运行的命令，这里是安装ruby，gem、bundler等软件。写好Dockerfile后，运行以下指令就可以创建你的base image了：</p>
<p>docker build –rm -t dev:base . </p>
<p>1<br>2<br>docker build –rm -t dev:base . </p>
<p>-t 选项是你要构建的base image的tag，就好比ubuntu:13.10一样 –rm 选项是告诉Docker在构建完成后删除临时的Container，Dockerfile的每一行指令都会创建一个临时的Container，一般你是不需要这些临时生成的Container的 如你所想，我们可以像运行ubuntu:13.10那样运行我们的base了：</p>
<p>docker run -i -t –name ruby dev:base irb </p>
<p>1<br>2<br>docker run -i -t –name ruby dev:base irb </p>
<p>这里我们使用dev:base这个Image运行了一个irb解释器（Ruby的交互式解释器）。 在构建完base之后，你可以依样画葫芦构建你的rails环境，很简单，只需要FROM dev:base，然后RUN安装你的rails组件就可以了，不再赘述。最终你可能构建的开发环境是这样的：</p>
<p>docker-dev</p>
<p>如上图所示，base和service都是从ubutnu:13.10继承而来，他们作为不同的基础开发环境，base是ruby开发环境（也许命名为dev:ruby更为合适？），而service是一些基础数据服务，例如mysql，memcache，我建议将这些第三方组件集中在一个Container中，因为他们的环境不经常修改，可以作为一种底层服务Container运行，除非你需要构建分布式的服务，例如memcache集群，那可以继续拆分。</p>
<p>指定Image入口</p>
<p>当你构建完你的base Image和其他应用的Image之后，你就可以启动这些Image了，还记得前面我们给出的运行命令吗？</p>
<p>docker run -i -t –name shell dev:base /bin/bash </p>
<p>1<br>2<br>docker run -i -t –name shell dev:base /bin/bash </p>
<p>这里我们运行了一个bash，这样你就可以在shell里面执行你所想要执行的任何命令了，但是我们有时候并不想每次都启动一个shell，接着再在shell里面启动我们的程序，比如一个mysql，而是想一启动一个容器，mysql服务就自动运行了，这很简单，Dockerfile提供了CMD和ENTRYPOINT这2个指令，允许你指定一个Image启动时的默认命令。CMD和ENTRYPOINT的区别是CMD的参数可以由docker run指令指定的参数覆盖，而ENTRYPOINT则不可以。例如我们想运行一个memcached服务，可以这么写Dockerfile：</p>
<p>FROM ubuntu:13.10<br>RUN apt-get install -y memcached CMD memcached -u root -p 40000 </p>
<p>1<br>2<br>3<br>FROM ubuntu:13.10<br>RUN apt-get install -y memcached CMD memcached -u root -p 40000 </p>
<p>或者可以这么写：</p>
<p>FROM ubuntu:13.10<br>RUN apt-get install -y memcached ENTRYPOINT [“memcached”, “-u”, “root”, “-p”, “40000”] </p>
<p>1<br>2<br>3<br>FROM ubuntu:13.10<br>RUN apt-get install -y memcached ENTRYPOINT [“memcached”, “-u”, “root”, “-p”, “40000”] </p>
<p>注意不要把memcached启动为后台进程，即加上-d选项，否则docker启动的container会马上stop掉，这点我也觉得比较意外。 接着我们build这个Image：</p>
<p>docker build -t dev:memcache . </p>
<p>1<br>2<br>docker build -t dev:memcache . </p>
<p>这样，当你build完你的Image后，你可以直接将该Image运行为一个容器，它会自动启动mysql服务：</p>
<p>docker run –name memcache_service -d dev:memcache </p>
<p>1<br>2<br>docker run –name memcache_service -d dev:memcache </p>
<p>注意使用-d (detach) 选项，这样这个container就会作为后台进程运行了，接着你可以使用docker ps命令查看是否有在运行。</p>
<p>磁盘映射</p>
<p>大部分时候你会需要把你host主机（宿主）上的目录映射到Container里面，这样你就非常方便地在host主机上编辑代码，然后直接就可以在Container里面运行它们，而不用手动copy到Container里面再重启Container。按理将host的目录映射到guest（指Container）上应该是一件很容易的事情，就好像VMWare那样，但可惜的是，由于Mac上的Docker多了一层虚拟机，因此多了一层周折，你必须先VM上的目录通过sshfs mount到host（指Mac）上，然后再将你的目录或文件copy到这个mount的目录，再将VM上的这个目录映射到Container里，听起来比较拗口，画个图会清晰很多。</p>
<p>docker-disk-map</p>
<p>如上图所示，VM里面的/mnt/sda1/dev/目录（你需要自己创建）通过sshfs命令mount到了host主机（Mac）的~/workspace/dev/目录 ，而VM里的/mnt/sda1/dev/目录又被映射到了Container的/src/目录下，这样你就可以在Container里面的/src/目录下访问你的host文件了。具体如何做呢？首先你需要安装sshfs命令，然后将VM的password写到一个文件中，例如~/.boot2docker/b2d-passwd，在用sshfs命令mount起VM的/mnt/sda1/dev目录：</p>
<p>brew install sshfs<br>cat tcuser &gt; ~/.boot2docker/b2d-passwd<br>sshfs docker@localhost:/mnt/sda1/dev ~/workspace/dev -p 2022 -o reconnect -o password_stdin &lt; ~/.boot2docker/b2d-passwd </p>
<p>1<br>2<br>3<br>4<br>brew install sshfs<br>cat tcuser &gt; ~/.boot2docker/b2d-passwd<br>sshfs docker@localhost:/mnt/sda1/dev ~/workspace/dev -p 2022 -o reconnect -o password_stdin &lt; ~/.boot2docker/b2d-passwd </p>
<p>接着你在run一个Container的时候需要通过-v选项来将/mnt/sda1/dev/映射到/src目录：</p>
<p>docker run -i -t dev:base -v /mnt/sda1/dev:/src /bin/bash </p>
<p>1<br>2<br>docker run -i -t dev:base -v /mnt/sda1/dev:/src /bin/bash </p>
<p>这样你就可以在你的Container的/src目录下看到你host里的文件了。 磁盘映射还有2个地方需要注意：</p>
<p>你的文件实际上是存储在VM里面的，也就是说你需要将你的目录或者文件copy到VM里面，你sshfs之后，就是copy到~/workspace/dev目录下<br>千万不要sshfs mount非/mnt/sda1下的目录，因为VM里面跑的是TinyCoreLinux，这个OS的rootfs是临时性的（放在内存的，实际上就是boot2docker.iso文件里面的一个rootfs），因此其根目录/下的东西（包括/home）根本不会持久化，只有/mnt/sda1这个目录下的才能持久化。如果你放在/home目录下，只要VM一重启，就会丢失的，/mnt/sda1则不会，实际上就是那个~/.boot2docker-vm.vmdk文件挂载到了/mnt/sda1目录下<br>端口映射</p>
<p>和磁盘映射一样，你有时候会需要将Container的端口映射到host主机上，同样蛋疼的是，由于多了一层VM，端口映射也显得比较麻烦。首先你需要设置VirtualBox的端口映射，然后再将Container的端口映射到你的VM里面：</p>
<p>docker-port-map</p>
<p>具体是这么做的，通过2条命令：</p>
<p>boot2docker ssh -L 8000:localhost:8000<br>docker run -i -t -p 8000:8000</p>
<p>1<br>2<br>3<br>boot2docker ssh -L 8000:localhost:8000<br>docker run -i -t -p 8000:8000</p>
<p>也就是说在docker run的时候通过-p选项指定要映射的端口到VM，而boot2docker ssh命令则是将VM的8000端口映射到了host(Mac)的8000端口，这样你就可以通过Mac的localhost:8000访问Container的8000端口了。 其实，有另一种解决方案就是你不用映射到host（Mac），而是直接登录到VM里面进行访问就好了，boot2docker ssh就可以登录到VM，这样就类似于你的host是ubuntu，但这种解决方案的问题是这个ubuntu太弱了（TinyCoreLinux），如果你在这个ubuntu里面开发代码，或者是运行浏览器，是非常蛋疼的事情，关键还是这个ubuntu是每次重启都会复原的！所以我建议还是做多一层映射好了。 最后，实际上在VM里面，你是可以直接访问所有的Container的端口的，因为VM到Container的网络都是桥接的。</p>
<p>其他的一些坑</p>
<p>在使用的过程中，还遇到一些不少的坑：</p>
<p>/etc/hosts文件无法修改，这样你就不能自己做域名解析<br>VM的系统时间是UTC +0000的，而且貌似无法修改<br>Container的IP无法指定为静态IP，因此每次重启Container时，IP可能会变化<br>第1个问题的解决方案是通过安装dnsmasq软件来做域名解析：</p>
<h1 id="首先，在你的Container里面安装dnsmasq软件"><a href="#首先，在你的Container里面安装dnsmasq软件" class="headerlink" title="首先，在你的Container里面安装dnsmasq软件:"></a>首先，在你的Container里面安装dnsmasq软件:</h1><p>apt-get install dnsmasq</p>
<h1 id="将以下文本添加到-etc-dnsmasq-conf文件的最后："><a href="#将以下文本添加到-etc-dnsmasq-conf文件的最后：" class="headerlink" title="将以下文本添加到 /etc/dnsmasq.conf文件的最后："></a>将以下文本添加到 /etc/dnsmasq.conf文件的最后：</h1><p>listen-address=127.0.0.1 resolv-file=/etc/resolv.dnsmasq.conf conf-dir=/etc/dnsmasq.d user=root</p>
<h1 id="接着在-etc-dnsmasq-d-目录下新建一个文件，随意起个名字"><a href="#接着在-etc-dnsmasq-d-目录下新建一个文件，随意起个名字" class="headerlink" title="接着在/etc/dnsmasq.d/目录下新建一个文件，随意起个名字"></a>接着在/etc/dnsmasq.d/目录下新建一个文件，随意起个名字</h1><p>vi /etc/dnsmqsq.d/dns.conf</p>
<h1 id="指定你要映射的域名，例如google-com，则将下面贴进dns-conf文件"><a href="#指定你要映射的域名，例如google-com，则将下面贴进dns-conf文件" class="headerlink" title="指定你要映射的域名，例如google.com，则将下面贴进dns.conf文件"></a>指定你要映射的域名，例如google.com，则将下面贴进dns.conf文件</h1><p>address=”/google.com/172.17.0.4”</p>
<h1 id="最后退出容器，重启启动容器时，通过-dns选项指定域名服务器"><a href="#最后退出容器，重启启动容器时，通过-dns选项指定域名服务器" class="headerlink" title="最后退出容器，重启启动容器时，通过-dns选项指定域名服务器"></a>最后退出容器，重启启动容器时，通过-dns选项指定域名服务器</h1><p>docker run -i -t -dns 127.0.0.1 -dns 8.8.8.8 dev:base /bin/bash</p>
<h1 id="一定要注意上面添加google的域名服务器8-8-8-8，否则你访问不了外网"><a href="#一定要注意上面添加google的域名服务器8-8-8-8，否则你访问不了外网" class="headerlink" title="一定要注意上面添加google的域名服务器8.8.8.8，否则你访问不了外网"></a>一定要注意上面添加google的域名服务器8.8.8.8，否则你访问不了外网</h1><h1 id="进去Container后，启动dnsmasq，这样你就能够ping-google-com了"><a href="#进去Container后，启动dnsmasq，这样你就能够ping-google-com了" class="headerlink" title="进去Container后，启动dnsmasq，这样你就能够ping google.com了"></a>进去Container后，启动dnsmasq，这样你就能够ping google.com了</h1><p>/etc/init.d/dnsmasq start</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26</p>
<h1 id="首先，在你的Container里面安装dnsmasq软件-1"><a href="#首先，在你的Container里面安装dnsmasq软件-1" class="headerlink" title="首先，在你的Container里面安装dnsmasq软件:"></a>首先，在你的Container里面安装dnsmasq软件:</h1><p>apt-get install dnsmasq</p>
<h1 id="将以下文本添加到-etc-dnsmasq-conf文件的最后：-1"><a href="#将以下文本添加到-etc-dnsmasq-conf文件的最后：-1" class="headerlink" title="将以下文本添加到 /etc/dnsmasq.conf文件的最后："></a>将以下文本添加到 /etc/dnsmasq.conf文件的最后：</h1><p>listen-address=127.0.0.1 resolv-file=/etc/resolv.dnsmasq.conf conf-dir=/etc/dnsmasq.d user=root</p>
<h1 id="接着在-etc-dnsmasq-d-目录下新建一个文件，随意起个名字-1"><a href="#接着在-etc-dnsmasq-d-目录下新建一个文件，随意起个名字-1" class="headerlink" title="接着在/etc/dnsmasq.d/目录下新建一个文件，随意起个名字"></a>接着在/etc/dnsmasq.d/目录下新建一个文件，随意起个名字</h1><p>vi /etc/dnsmqsq.d/dns.conf</p>
<h1 id="指定你要映射的域名，例如google-com，则将下面贴进dns-conf文件-1"><a href="#指定你要映射的域名，例如google-com，则将下面贴进dns-conf文件-1" class="headerlink" title="指定你要映射的域名，例如google.com，则将下面贴进dns.conf文件"></a>指定你要映射的域名，例如google.com，则将下面贴进dns.conf文件</h1><p>address=”/google.com/172.17.0.4”</p>
<h1 id="最后退出容器，重启启动容器时，通过-dns选项指定域名服务器-1"><a href="#最后退出容器，重启启动容器时，通过-dns选项指定域名服务器-1" class="headerlink" title="最后退出容器，重启启动容器时，通过-dns选项指定域名服务器"></a>最后退出容器，重启启动容器时，通过-dns选项指定域名服务器</h1><p>docker run -i -t -dns 127.0.0.1 -dns 8.8.8.8 dev:base /bin/bash</p>
<h1 id="一定要注意上面添加google的域名服务器8-8-8-8，否则你访问不了外网-1"><a href="#一定要注意上面添加google的域名服务器8-8-8-8，否则你访问不了外网-1" class="headerlink" title="一定要注意上面添加google的域名服务器8.8.8.8，否则你访问不了外网"></a>一定要注意上面添加google的域名服务器8.8.8.8，否则你访问不了外网</h1><h1 id="进去Container后，启动dnsmasq，这样你就能够ping-google-com了-1"><a href="#进去Container后，启动dnsmasq，这样你就能够ping-google-com了-1" class="headerlink" title="进去Container后，启动dnsmasq，这样你就能够ping google.com了"></a>进去Container后，启动dnsmasq，这样你就能够ping google.com了</h1><p>/etc/init.d/dnsmasq start</p>
<p>第2个问题的解决方案就稍微麻烦些，起码我没有找到更好的解决方案，我是将boot2docker.iso文件重新制作一次来解决这个问题的：</p>
<h1 id="首先你需要将boot2docker-iso文件mount到一个目录下"><a href="#首先你需要将boot2docker-iso文件mount到一个目录下" class="headerlink" title="首先你需要将boot2docker.iso文件mount到一个目录下"></a>首先你需要将boot2docker.iso文件mount到一个目录下</h1><p>hdiutil mount ~/.boot2docker/boot2docker.iso</p>
<h1 id="系统会mount到-Volumes-boot2docker目录下，然后你最好将这下面的东西copy出来到一个另外的目录，这样我们好制作一张新的ISO"><a href="#系统会mount到-Volumes-boot2docker目录下，然后你最好将这下面的东西copy出来到一个另外的目录，这样我们好制作一张新的ISO" class="headerlink" title="系统会mount到/Volumes/boot2docker目录下，然后你最好将这下面的东西copy出来到一个另外的目录，这样我们好制作一张新的ISO"></a>系统会mount到/Volumes/boot2docker目录下，然后你最好将这下面的东西copy出来到一个另外的目录，这样我们好制作一张新的ISO</h1><p>cp -r /Volumes/boot2docker/* ~/tmp/</p>
<h1 id="接着我们修改以下文件"><a href="#接着我们修改以下文件" class="headerlink" title="接着我们修改以下文件"></a>接着我们修改以下文件</h1><p>vi ~/tmp/boot/isolinux/isolinux.cfg</p>
<h1 id="将其中的以下这行修改："><a href="#将其中的以下这行修改：" class="headerlink" title="将其中的以下这行修改："></a>将其中的以下这行修改：</h1><p>append loglevel=3 user=docker console=ttyS0 console=tty0 nomodeset norestore base</p>
<h1 id="修改为：（其实就是加了tz的启动参数），然后保存"><a href="#修改为：（其实就是加了tz的启动参数），然后保存" class="headerlink" title="修改为：（其实就是加了tz的启动参数），然后保存"></a>修改为：（其实就是加了tz的启动参数），然后保存</h1><p>append tz=CST-8 loglevel=3 user=docker console=ttyS0 console=tty0 nomodeset norestore base</p>
<h1 id="接着你必须在ubuntu环境下重新制作ISO文件，你可以利用docker跑一个ubuntu，哈哈，假设你将boot2docker目录copy到了ubuntu的-src-目录下，那么接着这么做"><a href="#接着你必须在ubuntu环境下重新制作ISO文件，你可以利用docker跑一个ubuntu，哈哈，假设你将boot2docker目录copy到了ubuntu的-src-目录下，那么接着这么做" class="headerlink" title="接着你必须在ubuntu环境下重新制作ISO文件，你可以利用docker跑一个ubuntu，哈哈，假设你将boot2docker目录copy到了ubuntu的/src/目录下，那么接着这么做"></a>接着你必须在ubuntu环境下重新制作ISO文件，你可以利用docker跑一个ubuntu，哈哈，假设你将boot2docker目录copy到了ubuntu的/src/目录下，那么接着这么做</h1><h1 id="安装xorriso命令"><a href="#安装xorriso命令" class="headerlink" title="安装xorriso命令"></a>安装xorriso命令</h1><p>apt-get install xorriso</p>
<h1 id="构建ISO映射"><a href="#构建ISO映射" class="headerlink" title="构建ISO映射"></a>构建ISO映射</h1><p>xorriso -as mkisofs -J -R -V boot2docker -no-emul-boot -boot-load-size 4 -boot-info-table -b boot/isolinux/isolinux.bin -c boot/isolinux/boot.cat -o /boot2docker.iso /src/</p>
<h1 id="这样就生成了-boot2docker-iso文件，最后你就可以替换到VM的启动ISO文件了，然后重启VM了"><a href="#这样就生成了-boot2docker-iso文件，最后你就可以替换到VM的启动ISO文件了，然后重启VM了" class="headerlink" title="这样就生成了/boot2docker.iso文件，最后你就可以替换到VM的启动ISO文件了，然后重启VM了"></a>这样就生成了/boot2docker.iso文件，最后你就可以替换到VM的启动ISO文件了，然后重启VM了</h1><p>boot2docker restart</p>
<h1 id="最后你必须设置你的VM为正确的时间，使用date-s-命令，最后用date命令查看，你就能看到CST时区的正确时间了"><a href="#最后你必须设置你的VM为正确的时间，使用date-s-命令，最后用date命令查看，你就能看到CST时区的正确时间了" class="headerlink" title="最后你必须设置你的VM为正确的时间，使用date -s 命令，最后用date命令查看，你就能看到CST时区的正确时间了"></a>最后你必须设置你的VM为正确的时间，使用date -s 命令，最后用date命令查看，你就能看到CST时区的正确时间了</h1><p>Sun Mar 30 00:27:13 CST 2014</p>
<h1 id="对于你启动的container，你都必须重新设置TZ环境变量，否则即使VM是CST-8，你的container还是UCT-00-00的时间"><a href="#对于你启动的container，你都必须重新设置TZ环境变量，否则即使VM是CST-8，你的container还是UCT-00-00的时间" class="headerlink" title="对于你启动的container，你都必须重新设置TZ环境变量，否则即使VM是CST-8，你的container还是UCT +00:00的时间"></a>对于你启动的container，你都必须重新设置TZ环境变量，否则即使VM是CST-8，你的container还是UCT +00:00的时间</h1><p>export TZ=’CST-8’</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42</p>
<h1 id="首先你需要将boot2docker-iso文件mount到一个目录下-1"><a href="#首先你需要将boot2docker-iso文件mount到一个目录下-1" class="headerlink" title="首先你需要将boot2docker.iso文件mount到一个目录下"></a>首先你需要将boot2docker.iso文件mount到一个目录下</h1><p>hdiutil mount ~/.boot2docker/boot2docker.iso</p>
<h1 id="系统会mount到-Volumes-boot2docker目录下，然后你最好将这下面的东西copy出来到一个另外的目录，这样我们好制作一张新的ISO-1"><a href="#系统会mount到-Volumes-boot2docker目录下，然后你最好将这下面的东西copy出来到一个另外的目录，这样我们好制作一张新的ISO-1" class="headerlink" title="系统会mount到/Volumes/boot2docker目录下，然后你最好将这下面的东西copy出来到一个另外的目录，这样我们好制作一张新的ISO"></a>系统会mount到/Volumes/boot2docker目录下，然后你最好将这下面的东西copy出来到一个另外的目录，这样我们好制作一张新的ISO</h1><p>cp -r /Volumes/boot2docker/* ~/tmp/</p>
<h1 id="接着我们修改以下文件-1"><a href="#接着我们修改以下文件-1" class="headerlink" title="接着我们修改以下文件"></a>接着我们修改以下文件</h1><p>vi ~/tmp/boot/isolinux/isolinux.cfg</p>
<h1 id="将其中的以下这行修改：-1"><a href="#将其中的以下这行修改：-1" class="headerlink" title="将其中的以下这行修改："></a>将其中的以下这行修改：</h1><p>append loglevel=3 user=docker console=ttyS0 console=tty0 nomodeset norestore base</p>
<h1 id="修改为：（其实就是加了tz的启动参数），然后保存-1"><a href="#修改为：（其实就是加了tz的启动参数），然后保存-1" class="headerlink" title="修改为：（其实就是加了tz的启动参数），然后保存"></a>修改为：（其实就是加了tz的启动参数），然后保存</h1><p>append tz=CST-8 loglevel=3 user=docker console=ttyS0 console=tty0 nomodeset norestore base</p>
<h1 id="接着你必须在ubuntu环境下重新制作ISO文件，你可以利用docker跑一个ubuntu，哈哈，假设你将boot2docker目录copy到了ubuntu的-src-目录下，那么接着这么做-1"><a href="#接着你必须在ubuntu环境下重新制作ISO文件，你可以利用docker跑一个ubuntu，哈哈，假设你将boot2docker目录copy到了ubuntu的-src-目录下，那么接着这么做-1" class="headerlink" title="接着你必须在ubuntu环境下重新制作ISO文件，你可以利用docker跑一个ubuntu，哈哈，假设你将boot2docker目录copy到了ubuntu的/src/目录下，那么接着这么做"></a>接着你必须在ubuntu环境下重新制作ISO文件，你可以利用docker跑一个ubuntu，哈哈，假设你将boot2docker目录copy到了ubuntu的/src/目录下，那么接着这么做</h1><h1 id="安装xorriso命令-1"><a href="#安装xorriso命令-1" class="headerlink" title="安装xorriso命令"></a>安装xorriso命令</h1><p>apt-get install xorriso</p>
<h1 id="构建ISO映射-1"><a href="#构建ISO映射-1" class="headerlink" title="构建ISO映射"></a>构建ISO映射</h1><p>xorriso -as mkisofs -J -R -V boot2docker -no-emul-boot -boot-load-size 4 -boot-info-table -b boot/isolinux/isolinux.bin -c boot/isolinux/boot.cat -o /boot2docker.iso /src/</p>
<h1 id="这样就生成了-boot2docker-iso文件，最后你就可以替换到VM的启动ISO文件了，然后重启VM了-1"><a href="#这样就生成了-boot2docker-iso文件，最后你就可以替换到VM的启动ISO文件了，然后重启VM了-1" class="headerlink" title="这样就生成了/boot2docker.iso文件，最后你就可以替换到VM的启动ISO文件了，然后重启VM了"></a>这样就生成了/boot2docker.iso文件，最后你就可以替换到VM的启动ISO文件了，然后重启VM了</h1><p>boot2docker restart</p>
<h1 id="最后你必须设置你的VM为正确的时间，使用date-s-命令，最后用date命令查看，你就能看到CST时区的正确时间了-1"><a href="#最后你必须设置你的VM为正确的时间，使用date-s-命令，最后用date命令查看，你就能看到CST时区的正确时间了-1" class="headerlink" title="最后你必须设置你的VM为正确的时间，使用date -s 命令，最后用date命令查看，你就能看到CST时区的正确时间了"></a>最后你必须设置你的VM为正确的时间，使用date -s 命令，最后用date命令查看，你就能看到CST时区的正确时间了</h1><p>Sun Mar 30 00:27:13 CST 2014</p>
<h1 id="对于你启动的container，你都必须重新设置TZ环境变量，否则即使VM是CST-8，你的container还是UCT-00-00的时间-1"><a href="#对于你启动的container，你都必须重新设置TZ环境变量，否则即使VM是CST-8，你的container还是UCT-00-00的时间-1" class="headerlink" title="对于你启动的container，你都必须重新设置TZ环境变量，否则即使VM是CST-8，你的container还是UCT +00:00的时间"></a>对于你启动的container，你都必须重新设置TZ环境变量，否则即使VM是CST-8，你的container还是UCT +00:00的时间</h1><p>export TZ=’CST-8’</p>
<p>第三个问题暂时无法解决（可能需要编辑底层的LXC配置文件）。</p>
<p>docker的限制以及后续的一些想法</p>
<p>docker其实还是有一些限制的：</p>
<p>要求你的环境是Linux的，而且内核必须很新（&gt;= 2.6.27 (29)），这其实是LXC本身的限制，和docker无关<br>docker的Container目前host是不能修改的，当然有解决方案（dnsmasq）<br>docker的Container也暂时无法指定静态IP<br>用docker作为开发环境甚至是生产环境其实还有很多地方值得尝试：</p>
<p>在团队内部构建本地的仓库，标准化所有的开发环境，使得团队的新人可以快速上手<br>在生产环境部署docker，这其实是PAAS的虚拟化和自动化的一种方式，利用LXC和Docker能够更便捷地实施PAAS<br>尝试用docker做分布式集群模拟和测试，成本会更加低廉，更加容器维护</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/03/05/docker-develop/" data-id="cj4quikvq0003ne5s7691wfo7" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-norm" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/05/norm/" class="article-date">
  <time datetime="2016-03-04T16:42:54.000Z" itemprop="datePublished">2016-03-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/05/norm/">创业公司的这些问题…其实是常态</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>我自己在创业公司工作，很多朋友也都在创业。大家在一起交流的时候经常会说起一些共性的问题，时间久了，总结一下，这些问题，其实就是常态，无需大惊小怪。</p>
<p>关于「常态」的基本解释：</p>
<p>1.固定的姿态<br>2.平常的、正常的状态</p>
<p>因为是创业公司，所以就一定会有这些问题。而这些问题，对创业公司来说，即使得到了「完美」的解决，或许也只是带来边际效益提升，有些甚至并不是最关键的，只是对你造成了巨大干扰而已。要有个良好的心态去面对这些问题。</p>
<p>问题一：管理混乱</p>
<p>管理是很难的事情 – 这当然是废话。很多创业人真的未必是好的管理者，但他们具备别样的能力。公司在创业阶段最需要的是增长，在增长面前，甚至其他事情都不重要。除非，有的事情阻碍了增长，不得不解决。</p>
<p>如果你看到管理混乱，那么可能在这个阶段，需要这种牺牲去投入团队精力做更主要的事情。</p>
<p>管理需要公司最核心团队的人力成本。最极端的情况下，如果只有「管理有序可平稳前进「与」管理混乱但高速增长」，只能二选一，由你来做选择，会选哪一个?</p>
<p>问题二：内部流程制度缺失或不完善</p>
<p>这么说吧，我就没听过哪家公司不是这样的。创业公司本来就是轻装向前快跑，一旦慢下来就等于公司在慢性自杀。别人快，你慢，即使也有增长，那也是失败。</p>
<p>如果流程制度太完善了，那意味着花了很多资源在这些流程制度本身上，团队做事情难以突破条条框框，节奏快不起来。</p>
<p>真正的难点在于怎么达到某种平衡。流程制度不能完全缺失，但是矫枉过正也要不得。这考量公司创始人对这个问题的能力，也跟他的工作背景有直接关系，某种程度上说，也要突破既往思维的限制。</p>
<p>喜欢完善的制度完备的流程的人，建议他们去大公司工作。不是所有人都适合创业团队。创业这事儿听起来酷，实际都是哭活儿累活儿脏活儿。</p>
<p>问题三：招聘真他妈的困难</p>
<p>有些创业者很焦虑: 招人难。潜台词是：如果能找到更多更优秀的人，那恐怕我的项目早就成了。更有甚者：方案早就有了，就差一个 CTO 了。为什么优秀的人才找不到 ? 为什么工程师这么贵 ? 为什么我们公司招人这么难，你看某某团队招人就好像很容易…</p>
<p>其实，招聘的难题是所有公司都要面对的事情。不单单是你招不到人，大公司也招不到合适的人。你面对的问题跟其他人是一样的。</p>
<p>反过来想，招聘能力就是竞争力。有些人或是有些团队，或是有些公司，在这方面竞争力就是强。</p>
<p>只要你在创业团队或是小公司，你就永远都要面对招人难的问题。招人难并不是制约你的唯一障碍，看你投入多少资源、时间、资金、期权。</p>
<p>如果你什么都舍不得，那很难找到你想要的人。记住，这是个公平的自由竞争的人才市场。</p>
<p>问题四：新手专业人才的失落</p>
<p>这是个什么问题呢？举个例子，知乎上有人提问「入职后发现项目组代码异常混乱，我是留下还是离开?」我相信一个成熟的专业人才不会提出这样的疑问，因为他经历多了，自然会知道，不存在「代码干净」的项目，也没有什么专业团队在专业人眼里是没缺陷的。</p>
<p>某个领域的新手，因为并不清楚这个行业的正常情况如何，他所了解到的场景总是比较完美的，我相信他看过各种专业技术书籍，书中阐述的理念堪称完美，但是可操作性有多强呢? 新手并不知道。</p>
<p>什么是新手，刚进入某个领域，刚到某个公司，刚接触某项技术，你都是新手，你的有些认知是需要时间来锻炼的，并不是你看了几篇文章，看过几本书就能直接变成一个行家里手。</p>
<p>我的建议是，降低这些专业人才的心里预期。明确告诉他，你需要跟一些傻瓜跟一些笨蛋一起做事情。如果这些接受不了，那么这个人并不适合你的团队。</p>
<p>创业公司缺的是能解决问题的人，并不只需要聪明人。至于自以为聪明的人，那就更不需要。实际上，谁比谁傻呢?</p>
<p>问题五：为什么这么倒霉?</p>
<p>为什么又被竞争对手捣乱? 为什么网站被 DDoS ? 为什么我创业就这么难…</p>
<p>别自怨自艾，这些是正常的事。别问为什么会这样，因为这就是创业啊。哪一个创业者没经历过这些呢? 抗过去，有机会成。看不下去，赶紧散伙撤退。</p>
<p>你遇上这些事儿跟你的运气无关，倒是跟你的心理预期有关。</p>
<p>过于乐观过于悲观都不行。正常的情况就应该是像过山车一样，忽上忽下，这样才够刺激。</p>
<p>最后，我建议的是，如果你是创业团队的一员，你最好思考一下，有些问题是「常态」吗? 更应该着手解决的是什么问题? 创业的目标是做一个理想的「状态」，还是把事情搞定?</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/03/05/norm/" data-id="cj4quikwl000nne5sgybfp0oy" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-mac-ubuntu-finalspeed" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/02/28/mac-ubuntu-finalspeed/" class="article-date">
  <time datetime="2016-02-28T08:49:53.000Z" itemprop="datePublished">2016-02-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Vps/">Vps</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/28/mac-ubuntu-finalspeed/">FinalSpeed搭建配置</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="系统环境介绍"><a href="#系统环境介绍" class="headerlink" title="系统环境介绍"></a>系统环境介绍</h4><p>Vps系统:Ubuntu14.01<br>本机系统:Mac OS X 10.11.3</p>
<h4 id="Vps服务器操作"><a href="#Vps服务器操作" class="headerlink" title="Vps服务器操作"></a>Vps服务器操作</h4><p>安装并启动<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">wget http:<span class="comment">//www.banwagong.me/tools/install_fs.sh</span></div><div class="line">chmod +x install_fs.sh</div><div class="line">./install_fs.sh <span class="number">2</span>&gt;&amp;<span class="number">1</span> | tee install.log</div></pre></td></tr></table></figure></p>
<p>安装完成后的一些配置路径<br><img src="http://cdn.bestxiaoyu.com/images/vps-finalspeed.png" alt="安装完成后的一些配置路径"></p>
<p>查看是否正常开启服务 (tail -f /fs/server.log)<br><img src="http://cdn.bestxiaoyu.com/images/vps-config.png" alt="查看是否正常开启服务"></p>
<h4 id="本机环境操作"><a href="#本机环境操作" class="headerlink" title="本机环境操作"></a>本机环境操作</h4><p>下载FinalSpeed客户端(下载地址:)<br>Windows: <a href="http://fs.d1sm.net/finalspeed/finalspeed_install1.0.exe" target="_blank" rel="external">http://fs.d1sm.net/finalspeed/finalspeed_install1.0.exe</a><br>OS X、Linux: <a href="http://fs.d1sm.net/finalspeed/finalspeed_client1.0.zip" target="_blank" rel="external">http://fs.d1sm.net/finalspeed/finalspeed_client1.0.zip</a></p>
<p>终端输入:(需要root权限)<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo java -jar finalspeed_client.jar</div></pre></td></tr></table></figure></p>
<p>系统需安装java运行环境,Linux还需安装libpcap.<br>Ubuntu,Debian安装libpcap<br>    <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apt-get -y install libpcap-dev</div></pre></td></tr></table></figure></p>
<p>Centos安装libpcap<br>    <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum -y install libpcap</div></pre></td></tr></table></figure></p>
<p>JDK安装(已安装的请忽略)<br>    <a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="external">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></p>
<p>客户端配置如下：<br><img src="http://cdn.bestxiaoyu.com/images/client-config.png" alt=""><br>1、vps服务器地址<br>2、协议(看vps架构，openvz架构只支持udp协议，其他的尽量选择tcp协议)<br>3、检测是否连接成功</p>
<p>增加加速列表配置:<br><img src="http://cdn.bestxiaoyu.com/images/client-config2.png" alt=""><br>1、名称自定义<br>2、加速端口为ss加速端口<br>3、本地端口随意填写(我喜欢9099 :) )</p>
<p>Shadowsocks客户端配置：<br>新增一条服务器配置如下 端口号与FinalSpeed中本地端口号一致<br><img src="http://cdn.bestxiaoyu.com/images/shadowsocks-config.png" alt=""></p>
<h4 id="速度测试-Youtube有非常多本人喜欢的学习资料，因此Finalspeed是刚需"><a href="#速度测试-Youtube有非常多本人喜欢的学习资料，因此Finalspeed是刚需" class="headerlink" title="速度测试(Youtube有非常多本人喜欢的学习资料，因此Finalspeed是刚需)"></a>速度测试(Youtube有非常多本人喜欢的学习资料，因此Finalspeed是刚需)</h4><p><img src="http://cdn.bestxiaoyu.com/images/youtube-demo.png" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/02/28/mac-ubuntu-finalspeed/" data-id="cj4quikwh000ine5s0ber008t" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/FinalSpeed/">FinalSpeed</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vps/">Vps</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-python-mysql" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/02/25/python-mysql/" class="article-date">
  <time datetime="2016-02-25T06:51:49.000Z" itemprop="datePublished">2016-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Python/">Python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/25/python-mysql/">Python操作Mysql</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="下载MySQL-for-Python并解压"><a href="#下载MySQL-for-Python并解压" class="headerlink" title="下载MySQL for Python并解压"></a>下载MySQL for Python并解压</h4><p><a href="http://sourceforge.net/projects/mysql-python/" target="_blank" rel="external">http://sourceforge.net/projects/mysql-python/</a></p>
<h4 id="进入目录"><a href="#进入目录" class="headerlink" title="进入目录"></a>进入目录</h4><pre><code><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo python setup.py clean</div><div class="line">sudo python setup.py build</div><div class="line">sudo python setup.py install</div><div class="line">pip install MySQL-python</div></pre></td></tr></table></figure>
</code></pre><h4 id="解决-mysql-config-not-found-错误"><a href="#解决-mysql-config-not-found-错误" class="headerlink" title="解决 mysql_config not found 错误"></a>解决 mysql_config not found 错误</h4><p>在 MySQL-python 的安装包中找到 site.cfg 文件，打开它，找到以下内容:</p>
<pre><code><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># The path to mysql_config.</span></div><div class="line"><span class="comment"># Only use this if mysql_config is not on your PATH, or you have some weird</span></div><div class="line"><span class="comment"># setup that requires it.</span></div><div class="line"><span class="comment"># mysql_config = /usr/local/bin/mysql_config</span></div></pre></td></tr></table></figure>
</code></pre><p>将最后一句句首井号去掉，并修改为:</p>
<pre><code><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql_config = /usr/local/mysql/bin/mysql_config</div></pre></td></tr></table></figure>
</code></pre><p>然后执行:</p>
<pre><code><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ python setup.py install</div></pre></td></tr></table></figure>
</code></pre><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><pre><code><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> MySQLdb</div><div class="line"></div><div class="line"><span class="comment"># 打开数据库连接</span></div><div class="line">db = MySQLdb.connect(<span class="string">"localhost"</span>,<span class="string">"root"</span>,<span class="string">""</span>,<span class="string">"test"</span> )</div><div class="line"></div><div class="line"><span class="comment"># 使用cursor()方法获取操作游标 </span></div><div class="line">cursor = db.cursor()</div><div class="line"></div><div class="line"><span class="comment"># 使用execute方法执行SQL语句</span></div><div class="line">cursor.execute(<span class="string">"SELECT VERSION()"</span>)</div><div class="line"></div><div class="line"><span class="comment"># 使用 fetchone() 方法获取一条数据库。</span></div><div class="line">data = cursor.fetchone()</div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">"Database version : %s "</span> % data</div><div class="line"></div><div class="line"><span class="comment"># 创建数据表SQL语句</span></div><div class="line">sql = <span class="string">"""</span></div><div class="line">		CREATE TABLE EMPLOYEE (</div><div class="line">         FIRST_NAME  CHAR(20) NOT NULL,</div><div class="line">         LAST_NAME  CHAR(20),</div><div class="line">         AGE INT,  </div><div class="line">         SEX CHAR(1),</div><div class="line">         INCOME FLOAT )</div><div class="line">          """</div><div class="line"></div><div class="line">cursor.execute(sql)</div><div class="line"></div><div class="line"><span class="comment"># SQL 插入语句</span></div><div class="line">sql = <span class="string">"""</span></div><div class="line">		INSERT INTO EMPLOYEE(FIRST_NAME,</div><div class="line">         LAST_NAME, AGE, SEX, INCOME)</div><div class="line">         VALUES ('Mac', 'Mohan', 20, 'M', 2000)</div><div class="line">      """</div><div class="line"><span class="keyword">try</span>:</div><div class="line">   <span class="comment"># 执行sql语句</span></div><div class="line">   cursor.execute(sql)</div><div class="line">   <span class="comment"># 提交到数据库执行</span></div><div class="line">   db.commit()</div><div class="line"><span class="keyword">except</span>:</div><div class="line">   <span class="comment"># 发成错误时回滚</span></div><div class="line">   db.rollback()</div><div class="line"></div><div class="line"><span class="comment"># 关闭数据库连接</span></div><div class="line">db.close()</div></pre></td></tr></table></figure>
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/02/25/python-mysql/" data-id="cj4quikwy0014ne5sfixwn4tp" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-digitalocean-ubuntu-shdowsocks" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/02/24/digitalocean-ubuntu-shdowsocks/" class="article-date">
  <time datetime="2016-02-24T10:19:38.000Z" itemprop="datePublished">2016-02-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Vps/">Vps</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/24/digitalocean-ubuntu-shdowsocks/">Digitalocean Ubuntu系统搭建Shadowsocks</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Digitalocean打开需要梯子</div></pre></td></tr></table></figure>
<p><font color="red">用下面链接注册送10美刀</font><br><a href="https://m.do.co/c/0b957635d6aa" target="_blank" rel="external">https://m.do.co/c/0b957635d6aa</a></p>
<h4 id="Create-Droplet"><a href="#Create-Droplet" class="headerlink" title="Create Droplet"></a>Create Droplet</h4><p>注册完成之后进入Digitalocean首页 右上角Create Droplet<br><img src="http://cdn.bestxiaoyu.com/images/QQ20160224-0@2x.png" alt=""></p>
<hr>
<p>选择Ubuntu系统 14.04系统<br><img src="http://cdn.bestxiaoyu.com/images/QQ20160224-1@2x.png" alt=""></p>
<hr>
<p>选择自己需要的套餐 个人用的话$5就够了<br><img src="http://cdn.bestxiaoyu.com/images/QQ20160224-2@2x.png" alt=""></p>
<hr>
<p>机房地址选择，San Francisco比较稳定，速度相对也较快，推荐<br><img src="http://cdn.bestxiaoyu.com/images/QQ20160224-3@2x.png" alt=""></p>
<hr>
<p>hostname自己随意填吧<br><img src="http://cdn.bestxiaoyu.com/images/QQ20160224-4@2x.png" alt=""></p>
<hr>
<p>存储公钥，没有公钥的话每次登陆需要输入密码，密码DO的邮件里会体现<br>公钥生成方式: 打开终端或者putty<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-keygen</div></pre></td></tr></table></figure></p>
<p>vim ~/.ssh/id_rsa.pub 复制里面内容放进SSH Key content保存</p>
<hr>
<p><img src="http://cdn.bestxiaoyu.com/images/QQ20160224-5@2x.png" alt=""></p>
<p>到此配置已完成，点Create吧。</p>
<h4 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h4><p>接下来终端或者putty登陆VPS<br><img src="http://cdn.bestxiaoyu.com/images/QQ20160224-6@2x.png" alt=""></p>
<hr>
<p>复制一下命令安装shadowsocks<br>    <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">apt-get update</div><div class="line">apt–get install python–gevent python–pip</div><div class="line">pip install shadowsocks</div></pre></td></tr></table></figure></p>
<p>接下来配置也比较简单，新建一个 config.json，或者其他名字的都行，位置可以放在/etc/下（默认没有这个文件，你要自己创建一个），或者home或者其他任何地方。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"server"</span>:<span class="string">"你的服务器地址"</span>,	</div><div class="line">    <span class="string">"server_port"</span>:<span class="number">8888</span>,</div><div class="line">    <span class="string">"local_address"</span>: <span class="string">"127.0.0.1"</span>,</div><div class="line">    <span class="string">"local_port"</span>:<span class="number">1080</span>,</div><div class="line">    <span class="string">"password"</span>:<span class="string">"你的密码"</span>,</div><div class="line">    <span class="string">"timeout"</span>:<span class="number">300</span>,</div><div class="line">    <span class="string">"method"</span>:<span class="string">"aes-256-cfb"</span>,</div><div class="line">    <span class="string">"fast_open"</span>: <span class="keyword">false</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h4 id="配置解读"><a href="#配置解读" class="headerlink" title="配置解读"></a>配置解读</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">server 服务器 IP (IPv4/IPv6)，注意这也将是服务端监听的 IP 地址</div><div class="line">server_port 服务器端口</div><div class="line">local_port 本地端端口</div><div class="line">password 用来加密的密码</div><div class="line">timeout 超时时间（秒）</div><div class="line">method 加密方法，可选择“bf-cfb”,“aes-256-cfb”,“des-cfb”,“rc4”,等等。默认是一种不安全的加密，推荐用“aes-256-cfb”</div></pre></td></tr></table></figure>
<hr>
<h4 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nohup ssserver -c /etc/shadowsocks.json &gt; log &amp;</div></pre></td></tr></table></figure>
<hr>
<h4 id="配置开机自启动"><a href="#配置开机自启动" class="headerlink" title="配置开机自启动"></a>配置开机自启动</h4><p>然后可以配置开机自启动，添加到 /etc/rc.local<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/local/bin/ssserver –c /etc/shadowsocks.json</div></pre></td></tr></table></figure></p>
<hr>
<blockquote>
<p>微信扫一扫，请博主喝杯咖啡.<br><img src="http://cdn.bestxiaoyu.com/images%2Fcoffee.png?imageView2/1/w/200/h/200/q/75" alt="微信扫一扫，请博主喝杯咖啡."></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/02/24/digitalocean-ubuntu-shdowsocks/" data-id="cj4quikvi0001ne5syjdzpyp8" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Digitalocean/">Digitalocean</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Shadowsocks/">Shadowsocks</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Ubuntu/">Ubuntu</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vps/">Vps</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-python-douban-movies-pic" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/02/23/python-douban-movies-pic/" class="article-date">
  <time datetime="2016-02-23T06:12:48.000Z" itemprop="datePublished">2016-02-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Python/">Python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/23/python-douban-movies-pic/">Python网络爬虫(二) - 爬取豆瓣电影图片</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="爬取页面地址"><a href="#爬取页面地址" class="headerlink" title="爬取页面地址"></a>爬取页面地址</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://movie.douban.com/nowplaying/nanjing/</div></pre></td></tr></table></figure>
<h4 id="豆瓣电影页面源代码"><a href="#豆瓣电影页面源代码" class="headerlink" title="豆瓣电影页面源代码"></a>豆瓣电影页面源代码</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"> &lt;ul class=""&gt;</div><div class="line">&lt;li class="poster"&gt;</div><div class="line">    &lt;a href="http://movie.douban.com/subject/26334559/?from=playing_poster" class=ticket-btn target="_blank" data-psource="poster"&gt;</div><div class="line">        &lt;img src="http://img3.doubanio.com/view/movie_poster_cover/mpst/public/p2309171908.jpg" alt="澳门风云3" rel="nofollow" class="" /&gt;</div><div class="line">    &lt;/a&gt;</div><div class="line">&lt;/li&gt;</div><div class="line">&lt;li class="stitle"&gt;</div><div class="line">    &lt;a href="http://movie.douban.com/subject/26334559/?from=playing_poster"</div><div class="line">        class="ticket-btn"</div><div class="line">        target="_blank"</div><div class="line">        title="澳门风云3"</div><div class="line">        data-psource="title"&gt;</div><div class="line">        澳门风云3</div><div class="line">    &lt;/a&gt;</div><div class="line">&lt;/li&gt;</div></pre></td></tr></table></figure>
<p>图片链接就在li这个标签下地img标签里.现在我们需要做的就是尝试着把这种类型的li从所有html中分离出来.我们可以看到li这个标签有个属性叫做class,这个属性的值是class=”poster”</p>
<p>再仔细分析下,img这个标签在li这个标签里有且只有一个.那么,也就是说,我们先搜索出所有符合条件的li标签,然后找到里面的img标签就可以找到所有的图片链接了.</p>
<p>alt为图片名</p>
<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment">#-*- coding: utf-8 -*-</span></div><div class="line"><span class="comment">#encoding=utf-8</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> urllib2</div><div class="line"><span class="keyword">import</span> urllib</div><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">from</span> BeautifulSoup <span class="keyword">import</span> BeautifulSoup</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">getAllImageLink</span><span class="params">()</span>:</span></div><div class="line">    html = urllib2.urlopen(<span class="string">'http://movie.douban.com/nowplaying/nanjing/'</span>).read()</div><div class="line">    soup = BeautifulSoup(html)</div><div class="line"></div><div class="line">    liResult = soup.findAll(<span class="string">'li'</span>,attrs=&#123;<span class="string">"class"</span>:<span class="string">"poster"</span>&#125;)</div><div class="line">    <span class="keyword">for</span> li <span class="keyword">in</span> liResult:</div><div class="line">        imageEntityArray = li.findAll(<span class="string">'img'</span>)</div><div class="line">        <span class="keyword">for</span> image <span class="keyword">in</span> imageEntityArray:</div><div class="line">            link = image.get(<span class="string">'src'</span>)</div><div class="line">            imageName = image.get(<span class="string">'alt'</span>)</div><div class="line">            filesavepath = <span class="string">'/Users/DonxYu/Desktop/pic/%s.jpg'</span> % imageName </div><div class="line">            urllib.urlretrieve(link,filesavepath)</div><div class="line">            <span class="keyword">print</span> filesavepath </div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    getAllImageLink()</div></pre></td></tr></table></figure>
<p><img src="http://cdn.bestxiaoyu.com/images/QQ20160223-0@2x.png" alt=""></p>
<p><img src="http://cdn.bestxiaoyu.com/images/QQ20160223-1@2x.png" alt=""></p>
<hr>
<blockquote>
<p>微信扫一扫，请博主喝杯咖啡.<br><img src="http://cdn.bestxiaoyu.com/images%2Fcoffee.png?imageView2/1/w/200/h/200/q/75" alt="微信扫一扫，请博主喝杯咖啡."></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/02/23/python-douban-movies-pic/" data-id="cj4quikwv0011ne5s1tbz6e29" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/爬虫/">爬虫</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-python-spider" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/02/23/python-spider/" class="article-date">
  <time datetime="2016-02-23T05:56:19.000Z" itemprop="datePublished">2016-02-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Python/">Python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/23/python-spider/">Python网络爬虫(一) - 依赖</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#pip 和 easy_install 都是 Python 的框架管理命令，pip 是对 easy_install的升级</span></div><div class="line">sudo easy_install pip</div><div class="line"></div><div class="line"><span class="comment">#安装 Scrapy</span></div><div class="line">sudo pip install Scrapy</div><div class="line"></div><div class="line"><span class="comment">#解析html超级好用</span></div><div class="line">sudo pip install BeautifulSoup</div><div class="line"></div><div class="line"><span class="comment">#PIL是Python的图形处理库，在学习爬虫的时候可以用来处理验证码</span></div><div class="line">sudo pip install pil</div></pre></td></tr></table></figure>
<h4 id="安装BeautifulSoup"><a href="#安装BeautifulSoup" class="headerlink" title="安装BeautifulSoup"></a>安装BeautifulSoup</h4><p>官网下载最新的包beautifulsoup4 4.3.2，然后解压缩，从终端进入该目录<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo python setup.py install</div></pre></td></tr></table></figure></p>
<h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>easy_install使用方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">安装：easy_install PackageName</div><div class="line">删除：easy_install -m PackageName</div><div class="line">更新：easy_install -U PackageName</div></pre></td></tr></table></figure></p>
<p>pip使用方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">安装：pip install PackageName</div><div class="line">删除：pip uninstall PackageName</div><div class="line">更新：pip install -U PackageName</div><div class="line">搜索：pip search PackageName</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/02/23/python-spider/" data-id="cj4quikx20016ne5s8p90u21k" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/爬虫/">爬虫</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-hexo-ftp" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/02/19/hexo-ftp/" class="article-date">
  <time datetime="2016-02-19T03:23:15.000Z" itemprop="datePublished">2016-02-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Hexo/">Hexo</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/19/hexo-ftp/">Hexo自动发布到ftp</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="安装hexo-deployer-ftp"><a href="#安装hexo-deployer-ftp" class="headerlink" title="安装hexo-deployer-ftp"></a>安装hexo-deployer-ftp</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-deployer-ftp --save</div></pre></td></tr></table></figure>
<h4 id="必须先安装lftp"><a href="#必须先安装lftp" class="headerlink" title="必须先安装lftp"></a>必须先安装lftp</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ubuntu安装: apt-get install lftp</div><div class="line">mac安装: brew install lftp</div></pre></td></tr></table></figure>
<h4 id="修改-config-yml"><a href="#修改-config-yml" class="headerlink" title="修改_config.yml"></a>修改_config.yml</h4><p>添加插件:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">plugins:</div><div class="line">- hexo-deployer-ftp</div></pre></td></tr></table></figure></p>
<p>添加发布方式:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  type: ftp</div><div class="line">  host: &lt;ftp host&gt;</div><div class="line">  user: &lt;ftp user&gt;</div><div class="line">  root: &lt;path/to/your/blog/on/the/server&gt;</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/02/19/hexo-ftp/" data-id="cj4quikw8000bne5svoehsef3" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ftp/">ftp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hexo/">hexo</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/自动发布/">自动发布</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Catégories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Books/">Books</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Life/">Life</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Movie/">Movie</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Objective-C/">Objective-C</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vps/">Vps</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web/">Web</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Work/">Work</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/npm/">npm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/性能/">性能</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/性能优化/">性能优化</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Mot-clés</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Books/">Books</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Debian/">Debian</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Digitalocean/">Digitalocean</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Dropbox/">Dropbox</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/FinalSpeed/">FinalSpeed</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Life/">Life</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Meeting/">Meeting</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Movie/">Movie</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Shadowsocks/">Shadowsocks</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TV/">TV</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ubuntu/">Ubuntu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vps/">Vps</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vultr/">Vultr</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Work/">Work</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ftp/">ftp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/next/">next</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sidebar/">sidebar</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/后端开发/">后端开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/安全/">安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/极路由/">极路由</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/爬虫/">爬虫</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/美剧/">美剧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/自动发布/">自动发布</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/词/">词</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/黑客/">黑客</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Nuage de mot-clés</h3>
    <div class="widget tagcloud">
      <a href="/tags/Books/" style="font-size: 10px;">Books</a> <a href="/tags/Debian/" style="font-size: 10px;">Debian</a> <a href="/tags/Digitalocean/" style="font-size: 10px;">Digitalocean</a> <a href="/tags/Dropbox/" style="font-size: 10px;">Dropbox</a> <a href="/tags/FinalSpeed/" style="font-size: 10px;">FinalSpeed</a> <a href="/tags/Life/" style="font-size: 10px;">Life</a> <a href="/tags/Meeting/" style="font-size: 10px;">Meeting</a> <a href="/tags/Movie/" style="font-size: 10px;">Movie</a> <a href="/tags/Python/" style="font-size: 13.33px;">Python</a> <a href="/tags/Shadowsocks/" style="font-size: 16.67px;">Shadowsocks</a> <a href="/tags/TV/" style="font-size: 10px;">TV</a> <a href="/tags/Ubuntu/" style="font-size: 10px;">Ubuntu</a> <a href="/tags/Vps/" style="font-size: 20px;">Vps</a> <a href="/tags/Vultr/" style="font-size: 10px;">Vultr</a> <a href="/tags/Work/" style="font-size: 10px;">Work</a> <a href="/tags/ftp/" style="font-size: 10px;">ftp</a> <a href="/tags/hexo/" style="font-size: 13.33px;">hexo</a> <a href="/tags/next/" style="font-size: 10px;">next</a> <a href="/tags/python/" style="font-size: 10px;">python</a> <a href="/tags/sidebar/" style="font-size: 10px;">sidebar</a> <a href="/tags/后端开发/" style="font-size: 10px;">后端开发</a> <a href="/tags/安全/" style="font-size: 10px;">安全</a> <a href="/tags/极路由/" style="font-size: 10px;">极路由</a> <a href="/tags/爬虫/" style="font-size: 13.33px;">爬虫</a> <a href="/tags/美剧/" style="font-size: 10px;">美剧</a> <a href="/tags/自动发布/" style="font-size: 10px;">自动发布</a> <a href="/tags/词/" style="font-size: 10px;">词</a> <a href="/tags/黑客/" style="font-size: 10px;">黑客</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">October 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">August 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">March 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Articles récents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/06/14/你不是Google，一语点醒技术人/">(no title)</a>
          </li>
        
          <li>
            <a href="/2016/03/05/spark/">Spark：一个高效的分布式计算系统</a>
          </li>
        
          <li>
            <a href="/2016/03/05/docker-develop/">利用Docker构建开发环境</a>
          </li>
        
          <li>
            <a href="/2016/03/05/norm/">创业公司的这些问题…其实是常态</a>
          </li>
        
          <li>
            <a href="/2016/02/28/mac-ubuntu-finalspeed/">FinalSpeed搭建配置</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 John Doe<br>
      Propulsé by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>